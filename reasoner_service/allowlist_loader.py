"""
Allowlist Loader: Deterministic group key allowlist management.

Loads results/allowlist.json (generated by scripts/build_allowlist_from_replay.py)
and maintains a cached set of allowed group keys for policy gating.

Group key format: symbol|timeframe|session|signal_type|direction

Deterministic behavior:
- Same file â†’ same cached set
- Fail-open if file missing/unreadable (do not veto)
- Thread-safe caching
"""

import json
import threading
from pathlib import Path
from typing import Set, Optional, Dict, Any

from .logging_setup import logger


class AllowlistLoader:
    """Thread-safe cached loader for deterministic group key allowlist."""

    def __init__(self, json_path: Optional[str] = None):
        """Initialize loader with optional path to allowlist.json.

        Args:
            json_path: Path to allowlist.json. If None, no file is loaded initially.
        """
        self.json_path = json_path
        self._allowed_keys: Set[str] = set()
        self._loaded = False
        self._lock = threading.Lock()
        self._thresholds: Dict[str, Any] = {}
        self._metadata: Dict[str, Any] = {}

        # Load immediately if path provided
        if json_path:
            self.load(json_path)

    def load(self, json_path: str) -> bool:
        """Load allowlist JSON and cache allowed group keys.

        Args:
            json_path: Path to allowlist.json

        Returns:
            True if loaded successfully, False otherwise (fail-open)
        """
        try:
            path = Path(json_path)
            if not path.exists():
                logger.warning(f"Allowlist file not found: {json_path} (fail-open)")
                self._loaded = False
                return False

            with open(path, "r") as f:
                data = json.load(f)

            # Extract allowed groups
            allowed_groups = data.get("allowed_groups", [])
            thresholds = data.get("thresholds", {})
            metadata = {
                "timestamp": data.get("timestamp"),
                "source_replay_summary": data.get("source_replay_summary"),
                "total_allowed": data.get("total_allowed"),
                "total_groups_evaluated": data.get("total_groups_evaluated"),
            }

            # Build set of allowed keys (deterministic, no randomness)
            with self._lock:
                self._allowed_keys = set()
                for group in allowed_groups:
                    key = self._make_key(
                        symbol=group.get("symbol"),
                        timeframe=group.get("timeframe"),
                        session=group.get("session"),
                        signal_type=group.get("signal_type"),
                        direction=group.get("direction"),
                    )
                    if key:
                        self._allowed_keys.add(key)

                self._thresholds = thresholds
                self._metadata = metadata
                self._loaded = True

            logger.info(f"Allowlist loaded: {len(self._allowed_keys)} groups from {json_path}")
            return True

        except Exception as e:
            logger.warning(f"Failed to load allowlist from {json_path}: {e} (fail-open)")
            self._loaded = False
            return False

    def is_allowed(self, group_key: str) -> bool:
        """Check if group key is in allowlist.

        Args:
            group_key: Key in format symbol|timeframe|session|signal_type|direction

        Returns:
            True if in allowlist, False otherwise
        """
        with self._lock:
            return group_key in self._allowed_keys

    def is_enabled(self) -> bool:
        """Check if allowlist is loaded and enabled.

        Returns:
            True if loaded successfully, False if not loaded or loading failed
        """
        with self._lock:
            return self._loaded

    def get_allowed_keys(self) -> Set[str]:
        """Get copy of allowed keys set (thread-safe).

        Returns:
            Frozen set of allowed group keys
        """
        with self._lock:
            return frozenset(self._allowed_keys)

    def get_thresholds(self) -> Dict[str, Any]:
        """Get thresholds used to build allowlist.

        Returns:
            Thresholds dict (min_samples, min_expectancy, max_drawdown_r, max_loss_streak)
        """
        with self._lock:
            return self._thresholds.copy()

    def get_metadata(self) -> Dict[str, Any]:
        """Get allowlist metadata (timestamp, counts, etc).

        Returns:
            Metadata dict
        """
        with self._lock:
            return self._metadata.copy()

    @staticmethod
    def _make_key(
        symbol: Optional[str],
        timeframe: Optional[str],
        session: Optional[str],
        signal_type: Optional[str],
        direction: Optional[str],
    ) -> Optional[str]:
        """Create group key from components (deterministic format).

        Args:
            symbol: Trading symbol (e.g. EURUSD)
            timeframe: Timeframe (e.g. 1h, 4h, 1d)
            session: Session (e.g. london, newyork, asian)
            signal_type: Signal type (e.g. bearish_bos, bullish_choch)
            direction: Trade direction (long, short)

        Returns:
            Key in format symbol|timeframe|session|signal_type|direction, or None if missing fields
        """
        if not all([symbol, timeframe, session, signal_type, direction]):
            return None
        return f"{symbol}|{timeframe}|{session}|{signal_type}|{direction}"

    @staticmethod
    def make_key_from_snapshot(snapshot: Dict[str, Any]) -> Optional[str]:
        """Create group key from decision snapshot (convenience method).

        Args:
            snapshot: Decision snapshot dict with symbol, timeframe, session, signal_type, direction

        Returns:
            Key or None if any required field missing
        """
        return AllowlistLoader._make_key(
            symbol=snapshot.get("symbol"),
            timeframe=snapshot.get("timeframe"),
            session=snapshot.get("session"),
            signal_type=snapshot.get("signal_type"),
            direction=snapshot.get("direction"),
        )
