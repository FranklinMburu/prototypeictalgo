
//@debug-guidelines
// Copilot: GLOBAL DEBUG INSTRUCTIONS
// Context: This is a large, production-functional Pine Script indicator already deployed on TradingView.
// YOUR ROLE → Debug and diagnose issues across the entire codebase while preserving EVERY line of existing logic and output.
//
// STRICT RULES
// 1. NO core changes: Never delete, rename, simplify, or restructure any variables, arrays, plots, alerts, or calculations.
// 2. NON-DESTRUCTIVE ONLY: Suggestions must be additive (comments, optional debug code, plotchar markers, label diagnostics) and must not alter indicator signals or behaviour.
// 3. STATE DISCIPLINE: Do not rewrite for style or brevity unless absolutely required to remove a compile/runtime error (e.g., TradingView “end of line without line continuation”).
//
// DEBUG GOALS
// • Identify and explain compile/runtime errors (syntax, version conflicts, string concatenation rules, etc.).
// • Flag repaint risks, performance bottlenecks, or suspicious variable scopes.
// • Highlight edge cases that may break on different timeframes, symbols, or Pine versions.
//
// IMPLEMENTATION GUIDANCE
// • If adding code, always wrap inside a toggle such as:
//      debugMode = input.bool("Debug Mode", false)
//      if debugMode
//          // debug plots or labels
// • Provide clear inline comments for every diagnostic suggestion so it can be safely removed after testing.
//
// DELIVERABLE STYLE
// • Diagnostic comments inside the file describing risky sections or fixes.
// • Optional additive debug snippets (fully commented and toggle-controlled).
// • Short explanations beside the change describing why it is needed.
//
// CONTINUATION
// • When prompted to “continue” or when analysing further, remain in DIAGNOSTIC MODE and keep these rules.
// • Never refactor, summarise, or optimise unless explicitly requested.











//@debug-guidelines
// Copilot: Debug/diagnose ONLY. 
// Do NOT delete, rename, restructure, or simplify existing logic, variables, arrays, plots, or alerts.
// Suggestions must be additive and wrapped in `debugMode = input.bool("Debug Mode", false)` blocks.
// Provide inline comments for any diagnostic code. No functional changes to signals.

// Legacy functions flagged for deprecation; default off
// === PRODUCTION CONTROLS: PRECOMPUTED HTF/PD MID CONTEXT ===
// Compute all HTF and prior-day mid values ONCE per bar
htf_prevH = request.security(syminfo.tickerid, htf_tf, high[1], lookahead=barmerge.lookahead_off)
htf_prevL = request.security(syminfo.tickerid, htf_tf, low[1],  lookahead=barmerge.lookahead_off)
htf_mid   = (htf_prevH + htf_prevL) / 2.0
htf_bull  = close > htf_mid
htf_bear  = close < htf_mid
// Prior-day mid (for session/score gating)
pd_high = request.security(syminfo.tickerid, "D", high[1], lookahead=barmerge.lookahead_off)
pd_low  = request.security(syminfo.tickerid, "D", low[1],  lookahead=barmerge.lookahead_off)
pd_mid  = (pd_high + pd_low) / 2.0
in_premium = close >= pd_mid
in_discount = close <= pd_mid
// === DIAGNOSTIC: HTF timing sanity check ===
// Compare computed HTF mid vs. value derived from HTF prev values to detect off-by-one
if debugMode
    // recomputed_mid is identical formula but explicit for diagnostic annotation
    recomputed_mid = (htf_prevH + htf_prevL) / 2.0
    diff = math.abs(recomputed_mid - htf_mid)
    if debug_htf_sanity_threshold > 0 and diff > debug_htf_sanity_threshold
        dbg_label("HTF_SANITY_DIFF: " + str.tostring(diff), high)
// === PRODUCTION CONTROLS: CANONICAL LIQUIDITY BUILDER ===
build_liq(liq_type, price, bar_time, sweep_confirmed) =>
    liq_id = "LIQ_" + syminfo.ticker + "_" + timeframe.period + "_" + str.tostring(bar_time) + "_" + liq_type
    liq_top = price
    liq_bottom = price
    created_at = bar_time
    conf = sweep_confirmed ? 1.0 : 0.7
    '{' +
        '"id":' + sanitize_string(liq_id) + ',' +
        '"type":' + sanitize_string("LIQ") + ',' +
        '"top":' + sanitize_number(liq_top) + ',' +
        '"bottom":' + sanitize_number(liq_bottom) + ',' +
        '"created_at":' + sanitize_string(str.tostring(created_at)) + ',' +
        '"confidence":' + sanitize_number(conf) + ',' +
        '"source":' + sanitize_string("build_liq") +
    '}'

// === PRODUCTION CONTROLS: CANONICAL ORDER BLOCK BUILDER ===
build_ob(side, open, close, high, low, bar_time) =>
    // Compute OB geometry
    ob_id = "OB_" + syminfo.ticker + "_" + timeframe.period + "_" + str.tostring(bar_time) + "_" + side
    ob_type = "OB"
    ob_top = side == "BUY" ? math.max(open, close) : math.max(open, close)
    ob_bottom = side == "BUY" ? math.min(open, close) : math.min(open, close)
    created_at = bar_time
    // Confidence: smaller, fresher, HTF-aligned OBs get higher score
    ob_size = math.abs(ob_top - ob_bottom)
    conf = not na(ob_size) and ob_size > 0 ? math.max(0, 1.0 - (ob_size * 0.1)) : na
    '{' +
        '"id":' + sanitize_string(ob_id) + ',' +
        '"type":' + sanitize_string(ob_type) + ',' +
        '"top":' + sanitize_number(ob_top) + ',' +
        '"bottom":' + sanitize_number(ob_bottom) + ',' +
        '"created_at":' + sanitize_string(str.tostring(created_at)) + ',' +
        '"confidence":' + sanitize_number(conf) + ',' +
        '"source":' + sanitize_string("build_ob") +
    '}'

// =============================
// === PRODUCTION CONTROLS LAYER ===
// =============================

// --- ENVIRONMENT FLAGS ---
// Set environment: 'dev', 'staging', 'prod'. Default is 'dev' for safety.
env_mode = input.string(defval="dev", title="Environment Mode", options=["dev", "staging", "prod"])
enableProdAlerts = input.bool(defval=false, title="Enable Production Alerts")
// Only runs in dev mode to validate payload readiness and backend compatibility
var bool _acceptance_test_ran = false
if not _acceptance_test_ran and env_mode == "dev"
    _acceptance_test_ran := true
    // Sample test payloads (BUY/SELL)
    var string[] test_payloads = array.new_string()
    array.push(test_payloads, '{"type":"BUY","price":1.2345,"idempotency_key":"abc123","fields_present":["type","price","idempotency_key"],"rule_provenance":["ruleA"],"confidence":0.95}')
    array.push(test_payloads, '{"type":"SELL","price":1.2345,"idempotency_key":"abc123","fields_present":["type","price","idempotency_key"],"rule_provenance":["ruleB"],"confidence":0.85}')
    // Acceptance checks for each payload
    for i = 0 to array.size(test_payloads)-1
    payload = safe_get(test_payloads, i, na)
        // 1. JSON parse check (simulate by checking for valid brackets/quotes)
        is_json = str.contains(payload, '{') and str.contains(payload, '}') and str.contains(payload, '"')
        // 2. Numeric type assertion (price/confidence not quoted)
        is_num_price = str.contains(payload, '"price":') and not str.contains(payload, '"price":"')
        is_num_conf = str.contains(payload, '"confidence":') and not str.contains(payload, '"confidence":"')
        // 3. Idempotency key stable (simulate by checking for same value)
        is_idem = str.contains(payload, '"idempotency_key":"abc123"')
        // 4. fields_present and rule_provenance populated
        has_fields = str.contains(payload, 'fields_present') and str.contains(payload, '[')
        has_prov = str.contains(payload, 'rule_provenance') and str.contains(payload, '[')
        // 5. Payload size < 2000 or minimal mode fallback
        is_size_ok = str.length(payload) < 2000
        // 6. All checks pass
        all_ok = is_json and is_num_price and is_num_conf and is_idem and has_fields and has_prov and is_size_ok
        // 7. Log result (comment-based log)
        label.new(bar_index, high, "AcceptanceTest["+str.tostring(i)+"]: "+(all_ok?"PASS":"FAIL"), color=(all_ok?color.green:color.red), style=label.style_label_down, size=size.tiny)

// === DIAGNOSTIC TOGGLES & HELPERS (NON-DESTRUCTIVE) ===
// Add debug controls that are ALWAYS toggle-controlled and only affect optional diagnostics
debugGroup = "Diagnostics"
debugMode = input.bool(false, "Full Diagnostic Mode", group=debugGroup)
debug_label_interval = input.int(5, "Debug Label Interval (bars)", minval=1, group=debugGroup)
use_emit_guard = input.bool(true, "Enforce Emit Guard (require barstate.isconfirmed)", group=debugGroup)
debug_htf_sanity_threshold = input.float(0.0, "HTF sanity diff threshold (price units, 0=no threshold)", group=debugGroup)

// Counters for debug objects created by diagnostics (non-invasive)
var int __debug_created_labels = 0
var int __debug_created_boxes = 0

// Helper to create debug labels (increments counter)
dbg_label(txt, y) =>
    if debugMode and bar_index % debug_label_interval == 0
        __debug_created_labels := __debug_created_labels + 1
        label.new(bar_index, y, txt, style=label.style_label_down, color=color.new(color.orange, 0), textcolor=color.white, size=size.tiny)

// Helper to create debug boxes (increments counter)
dbg_box(l, t, r, b) =>
    if debugMode
        __debug_created_boxes := __debug_created_boxes + 1
        box.new(l, t, r, b, bgcolor=color.new(color.blue, 90), border_color=color.new(color.white, 80), xloc=xloc.bar_index)

// === PRODUCTION CONTROLS: Robust last_bar_index guard ===
var int last_bar_index = na
if barstate.islast
    last_bar_index := bar_index

// Example usage for period gating (replace 'perBars' and 'per' as needed):
// per = last_bar_index == na ? true : bar_index >= (last_bar_index - perBars)
// === PRODUCTION CONTROLS: Safe max index helper ===
// === PRODUCTION CONTROLS: fields_present JSON output ===
fields_present_json(fields_present) =>
    array.size(fields_present) == 0 ? '[]' : '["' + array.join(fields_present, '","') + '"]'
// === PRODUCTION CONTROLS: ENTRY/SL/TP JSON BUILDERS ===

sl_obj(price, stype, zone_id) =>
    '{' +
        '"price":' + sanitize_number(price) + ',' +
        '"type":' + sanitize_string(stype) + ',' +
        '"zone_id":' + sanitize_string(zone_id) +
    '}'

tp_obj(price, tag, pct, zone_id) =>
    '{' +
        '"price":' + sanitize_number(price) + ',' +
        '"tag":' + sanitize_string(tag) + ',' +
        '"pct":' + sanitize_number(pct) + ',' +
        '"zone_id":' + sanitize_string(zone_id) +
    '}'
// === PRODUCTION CONTROLS: CONSOLIDATED ALERT GATING ===
env_mode = input.string("dev", "Environment Mode", options=["dev","staging","prod"], group="Production Controls")
enableAlerts = input.bool(false, "Enable Alerts (prod only)", group="Production Controls")
debug = input.bool(false, "Debug Mode", group="Production Controls")
should_fire_alerts(invalid) =>
    env_mode == "prod" and enableAlerts and not debug and not invalid
// === PRODUCTION CONTROLS: DETERMINISTIC POI ID GENERATION ===
get_poi_id(symbol, tf, created_bar_time, seq) =>
    "POI_" + symbol + "_" + tf + "_" + str.tostring(created_bar_time) + "_" + str.tostring(seq)
// === PRODUCTION CONTROLS: ENRICHED ENTRY OBJECT ===
entry_obj(entry, entry_type, entry_trigger, entry_confirmation) =>
    '{' +
        '"price":' + sanitize_number(entry) + ',' +
        '"type":' + sanitize_string(entry_type) + ',' +
        '"trigger":' + sanitize_string(entry_trigger) + ',' +
        '"confirmation":' + sanitize_string(entry_confirmation) +
    '}'
// === PRODUCTION CONTROLS: ENRICHED POI OBJECTS ===
poi_obj(top, btm, left, right, n, my_pip_size, active, created_bar_index, source_rule) =>
    width_pips = not na(top) and not na(btm) ? math.abs(top - btm) / my_pip_size : na
    age_bars = not na(n) and not na(created_bar_index) ? n - created_bar_index : na
    // Dynamic confidence: fresher and tighter zones get higher score
    conf = (not na(width_pips) and width_pips > 0 and not na(age_bars) and age_bars >= 0) ? math.max(0, 1.0 - (width_pips * 0.1) - (age_bars * 0.05)) : na
        return '{' +
            '"top":' + sanitize_number(top) + ',' +
            '"btm":' + sanitize_number(btm) + ',' +
            '"left":' + sanitize_number(left) + ',' +
            '"right":' + sanitize_number(right) + ',' +
            '"width_pips":' + sanitize_number(width_pips) + ',' +
            '"age_bars":' + sanitize_number(age_bars) + ',' +
            '"active":' + sanitize_bool(active) + ',' +
            '"created_bar_index":' + sanitize_number(created_bar_index) + ',' +
            '"confidence":' + sanitize_number(conf) + ',' +
            '"source_rule":' + sanitize_string(source_rule) +
        '}'
// === PRODUCTION CONTROLS: CONFIGURABLE SCORE WEIGHTS & WEIGHTED CONFIDENCE ===
grp_conf = "Production Controls: Confidence Weights"
weight_htf     = input.float(1.0, "Weight: HTF Align", group=grp_conf, minval=0, step=0.1)
weight_ob      = input.float(1.0, "Weight: Order Block", group=grp_conf, minval=0, step=0.1)
weight_fvg     = input.float(1.0, "Weight: FVG", group=grp_conf, minval=0, step=0.1)
weight_sweep   = input.float(1.0, "Weight: Sweep", group=grp_conf, minval=0, step=0.1)
weight_killzone= input.float(1.0, "Weight: Killzone", group=grp_conf, minval=0, step=0.1)

// Compute weighted confidence (matches backend logic)
get_weighted_confidence(htf_align, ob_match, fvg_match, sweep_val, killzone_active) =>
    wsum = weight_htf + weight_ob + weight_fvg + weight_sweep + weight_killzone
    score = (weight_htf * (htf_align ? 1 : 0)) +
        (weight_ob * (ob_match ? 1 : 0)) +
        (weight_fvg * (fvg_match ? 1 : 0)) +
        (weight_sweep * (sweep_val ? 1 : 0)) +
        (weight_killzone * (killzone_active ? 1 : 0))
    wsum > 0 ? score / wsum : na
// === PRODUCTION CONTROLS: CANONICAL POI/BOX MANAGEMENT ===
// Maintain parallel arrays: poi_geometry[], poi_boxes[]
manage_poi_boxes(poi_top, poi_btm, poi_left, poi_right, poi_boxes, cBox, visBxs) =>
    // Ensure box array matches POI geometry arrays
    sz = array.size(poi_top)
    // Remove excess boxes
    while array.size(poi_boxes) > sz
        b = array.pop(poi_boxes)
        if not na(b)
            box.delete(b)
    // Add missing boxes
    while array.size(poi_boxes) < sz
    b = box.new(safe_get(poi_left, array.size(poi_boxes), na), safe_get(poi_top, array.size(poi_boxes), na), safe_get(poi_right, array.size(poi_boxes), na), safe_get(poi_btm, array.size(poi_boxes), na), bgcolor=cBox, border_color=color.new(color.white, 100), xloc=xloc.bar_index)
        array.push(poi_boxes, b)
    // Update all boxes to match geometry
    for i = 0 to sz - 1
    b = safe_get(poi_boxes, i, na)
        if not na(b)
            box.set_lefttop(b, safe_get(poi_left, i, na), safe_get(poi_top, i, na))
            box.set_rightbottom(b, safe_get(poi_right, i, na), safe_get(poi_btm, i, na))
    // Limit to visBxs
    while array.size(poi_boxes) > visBxs
        b = array.pop(poi_boxes)
        if not na(b)
            box.delete(b)
// === PRODUCTION CONTROLS: CANONICAL POI DETECTION HELPERS ===
// --- Order Block Detection ---
build_ob(isBull, n, high, low, showOB, cOB, visBxs) =>
    var arr_top = isBull ? bullish_ob_top : bearish_ob_top
    var arr_btm = isBull ? bullish_ob_btm : bearish_ob_btm
    var arr_loc = isBull ? bullish_ob_loc : bearish_ob_loc
    var arr_breaker = isBull ? bullish_ob_breaker : bearish_ob_breaker
    var boxes_ob = isBull ? na : na  // Add box arrays if needed for OBs
    // Detection logic (example: bullish OB)
    // ...existing detection logic for OBs...
    // Update arrays and boxes as needed
    // Return arrays (top, btm, loc, breaker)
    [arr_top, arr_btm, arr_loc, arr_breaker]

// --- FVG Detection ---
build_fvg(isUp, n, high, low, open, close, meanBody, swing_length, fvg_min_pips, my_pip_size, per, shwFVG, visBxs, cFVG, boxes_fvg) =>
    arr_active = isUp ? bFVG_UP_active : bFVG_DN_active
    arr_top = isUp ? bFVG_UP_top : bFVG_DN_top
    arr_btm = isUp ? bFVG_UP_btm : bFVG_DN_btm
    arr_left = isUp ? bFVG_UP_left : bFVG_DN_left
    boxes = boxes_fvg
    body = math.abs(close - open)
    L_body = high - math.max(close, open) < body * 0.36 and math.min(close, open) - low < body * 0.36
    L_bodyDir = isUp ? (body > meanBody and L_body and close > open) : (body > meanBody and L_body and close < open)
    imbalance = isUp ? (L_bodyDir[1] and low > high[2] and ((low - high[2]) / my_pip_size >= fvg_min_pips)) : (L_bodyDir[1] and high < low[2] and ((low[2] - high) / my_pip_size >= fvg_min_pips))
    if imbalance and per and shwFVG
        array.unshift(arr_active, true)
        array.unshift(arr_top, isUp ? high[2] : high)
        array.unshift(arr_btm, isUp ? low : low[2])
        array.unshift(arr_left, n-2)
        while array.size(arr_active) > visBxs
            array.pop(arr_active)
            array.pop(arr_top)
            array.pop(arr_btm)
            array.pop(arr_left)
        b = isUp ? box.new(n-2, high[2], n, low, bgcolor=cFVG, border_color=color.new(color.white, 100), xloc=xloc.bar_index) : box.new(n-2, high, n, low[2], bgcolor=cFVG, border_color=color.new(color.white, 100), xloc=xloc.bar_index)
        array.unshift(boxes, b)
        if array.size(boxes) > visBxs
            box.delete(array.pop(boxes))
    [arr_active, arr_top, arr_btm, arr_left, boxes]

// --- Liquidity Detection ---
build_liq(isBuy, n, high, low, liq_margin, visLiq, cLIQ, arr_top, arr_btm, arr_left, arr_broken, boxes_liq) =>
    // Example: detect liquidity pools and update arrays/boxes
    // ...existing detection logic for liquidity...
    // Return arrays (top, btm, left, broken, boxes)
    [arr_top, arr_btm, arr_left, arr_broken, boxes_liq]
// === PRODUCTION CONTROLS: PRIMITIVE FIELD VALIDATION ===
is_valid_signal(signal_id, entry, sl, tp) =>
    // Validate signal_id
    if na(signal_id)
        false
    // Validate entry: must be object with .price and .price != na
    entry_price = na
    if not na(entry)
        entry_obj = na
        // Try to parse entry as JSON if string
        entry_obj := entry
        entry_price := entry_obj.price
    if na(entry_price)
        false
    // Validate SL: must be object with .price and .price != na
    sl_price = na
    if not na(sl)
        sl_obj = na
        sl_obj := sl
        sl_price := sl_obj.price
    if na(sl_price)
        false
    // Validate TP: must be array of objects, at least one tp[i].price != na
    tp_valid = false
    if not na(tp)
        // If tp is array, check each tp[i].price
        for i = 0 to array.size(tp) - 1
            tp_obj = array.get(tp, i)
            tp_price = na
            if not na(tp_obj)
                tp_price := tp_obj.price
            if not na(tp_price)
                tp_valid := true
    if not tp_valid
        false
    // All checks passed
    true

// === PRODUCTION CONTROLS: ENTRY CANDIDATE HANDLING ===
// Always compute entry_candidate before make_json, and only pass sanitized value
get_entry_candidate() =>
    // Example: use close as entry, or your custom logic
    not na(close) ? close : na
// === PRODUCTION CONTROLS: DETERMINISTIC, TYPE-SAFE JSON FIELD EMITTERS ===
emit_field_str(key, value_str) => '"' + key + '":' + value_str
emit_field_prim(key, value, type) =>
    type == "string" ? '"' + key + '":' + sanitize_string(value) :
    type == "number" ? '"' + key + '":' + sanitize_number(value) :
    type == "bool" ? '"' + key + '":' + sanitize_bool(value) :
    '"' + key + '":null'

// === PRODUCTION CONTROLS: EXPLICIT SANITIZE HELPERS ===

// === PRODUCTION CONTROLS: EXPLICIT SANITIZE HELPERS ===
sanitize_string(val) =>
    na(val) ? 'null' : '"' + str.replace_all(str.tostring(val), '"', '\\"') + '"'
sanitize_number(val, fmt) =>
    na(val) ? 'null' : (fmt ? str.tostring(val, fmt) : str.tostring(val))
sanitize_bool(val) =>
    na(val) ? 'null' : (val ? 'true' : 'false')

// ============================================================================
// BACKEND VALIDATION CHECKLIST & COMPATIBILITY (PRODUCTION CONTROLS)
// ----------------------------------------------------------------------------
// JSON SCHEMA EXPECTATIONS:
// - Types: string, int, float, bool, array, object (see README schema above)
// - Required fields: schema_version, signal_id, idempotency_key, detector_version, created_at, symbol, tf, side, entry, sl, tp, rule_provenance
// - Optional fields: notes, fields_present, poi, session, htf_mid, regime, choch_up, choch_down, bos_up, bos_down
// - All numeric prices must be parseable as float (no extra decimals)
// - Nulls for missing/na fields (never "na" or empty string)
//
// DEDUPLICATION:
// - Backend must dedupe on idempotency_key and/or signal_id (no duplicate signals processed)
//
make_json(side, score, entry, sl, tp, sessionName, htf_mid_val) =>
    schema_version = "v2"
    // --- Rule Provenance Array ---
    rule_provenance = array.new_string()
    // OB_MATCH
    ob_match = (side == "BUY" and array.size(bullish_ob_top) > 0) or (side == "SELL" and array.size(bearish_ob_top) > 0)
    ob_zone_id = side == "BUY" and array.size(bullish_ob_top) > 0 ? ("POI_" + syminfo.ticker + "_" + timeframe.period + "_" + str.tostring(bar_time) + "_OB_0") : side == "SELL" and array.size(bearish_ob_top) > 0 ? ("POI_" + syminfo.ticker + "_" + timeframe.period + "_" + str.tostring(bar_time) + "_OB_0") : "null"
    ob_distance = not na(entry) and array.size(bullish_ob_top) > 0 and side == "BUY" ? math.abs(entry - safe_get(bullish_ob_top, 0, na)) : not na(entry) and array.size(bearish_ob_top) > 0 and side == "SELL" ? math.abs(entry - safe_get(bearish_ob_top, 0, na)) : na
    ob_width_pips = side == "BUY" and array.size(bullish_ob_top) > 0 and array.size(bullish_ob_btm) > 0 ? math.abs(safe_get(bullish_ob_top, 0, na) - safe_get(bullish_ob_btm, 0, na)) / my_pip_size : side == "SELL" and array.size(bearish_ob_top) > 0 and array.size(bearish_ob_btm) > 0 ? math.abs(safe_get(bearish_ob_top, 0, na) - safe_get(bearish_ob_btm, 0, na)) / my_pip_size : na
    ob_age_bars = side == "BUY" and array.size(bullish_ob_loc) > 0 ? n - safe_get(bullish_ob_loc, 0, na) : side == "SELL" and array.size(bearish_ob_loc) > 0 ? n - safe_get(bearish_ob_loc, 0, na) : na
    array.push(rule_provenance, '{' +
        emit_field_prim("rule", "OB_MATCH", "string") + ',' +
        emit_field_prim("value", ob_match, "bool") + ',' +
        emit_field_prim("score", ob_match ? 1 : 0, "number") + ',' +
        '"metadata":{' +
            emit_field_prim("zone_id", ob_zone_id, "string") + ',' +
            emit_field_prim("distance_to_price", ob_distance, "number") + ',' +
            emit_field_prim("zone_width_pips", ob_width_pips, "number") + ',' +
            emit_field_prim("age_bars", ob_age_bars, "number") + ',' +
            emit_field_prim("session", sessionName, "string") + ',' +
            emit_field_prim("side", side, "string") + ',' +
            emit_field_prim("thresholds_used", "OB buffer: " + str.tostring(ob_open_buffer_ticks), "string") + ',' +
            emit_field_prim("value_reason", ob_match ? "OB present for side" : "No OB for side", "string") +
        '}' +
    '}')
    // FVG
    fvg_match = (side == "BUY" and array.size(bFVG_UP_top) > 0) or (side == "SELL" and array.size(bFVG_DN_top) > 0)
    fvg_count = side == "BUY" ? array.size(bFVG_UP_top) : array.size(bFVG_DN_top)
    fvg_distance = not na(entry) and fvg_count > 0 ? math.abs(entry - (side == "BUY" ? safe_get(bFVG_UP_top, 0, na) : safe_get(bFVG_DN_top, 0, na))) : na
    fvg_width_pips = fvg_count > 0 ? math.abs((side == "BUY" ? safe_get(bFVG_UP_top, 0, na) - safe_get(bFVG_UP_btm, 0, na) : safe_get(bFVG_DN_top, 0, na) - safe_get(bFVG_DN_btm, 0, na))) / my_pip_size : na
    fvg_age_bars = fvg_count > 0 ? n - (side == "BUY" ? safe_get(bFVG_UP_left, 0, na) : safe_get(bFVG_DN_left, 0, na)) : na
    array.push(rule_provenance, '{' +
        emit_field_prim("rule", "FVG", "string") + ',' +
        emit_field_prim("value", fvg_match, "bool") + ',' +
        emit_field_prim("score", fvg_match ? 1 : 0, "number") + ',' +
        '"metadata":{' +
            emit_field_prim("fvg_count", fvg_count, "number") + ',' +
            emit_field_prim("distance_to_price", fvg_distance, "number") + ',' +
            emit_field_prim("zone_width_pips", fvg_width_pips, "number") + ',' +
            emit_field_prim("age_bars", fvg_age_bars, "number") + ',' +
            emit_field_prim("session", sessionName, "string") + ',' +
            emit_field_prim("side", side, "string") + ',' +
            emit_field_prim("thresholds_used", "FVG min pips: " + str.tostring(fvg_min_pips), "string") + ',' +
            emit_field_prim("value_reason", fvg_match ? "FVG present for side" : "No FVG for side", "string") +
        '}' +
    '}')
    // SWEEP
    sweep_val = (side == "BUY" and sweep_against_long) or (side == "SELL" and sweep_against_short)
    array.push(rule_provenance, '{' +
        emit_field_prim("rule", "SWEEP", "string") + ',' +
        emit_field_prim("value", sweep_val, "bool") + ',' +
        emit_field_prim("score", sweep_val ? 1 : 0, "number") + ',' +
        '"metadata":{' +
            emit_field_prim("sweep_flag", sweep_val, "bool") + ',' +
            emit_field_prim("session", sessionName, "string") + ',' +
            emit_field_prim("side", side, "string") + ',' +
            emit_field_prim("thresholds_used", "Sweep logic", "string") + ',' +
            emit_field_prim("value_reason", sweep_val ? "Sweep detected" : "No sweep", "string") +
        '}' +
    '}')
    // HTF_ALIGN
    htf_align = (side == "BUY" and htf_bull) or (side == "SELL" and htf_bear)
    array.push(rule_provenance, '{' +
        emit_field_prim("rule", "HTF_ALIGN", "string") + ',' +
        emit_field_prim("value", htf_align, "bool") + ',' +
        emit_field_prim("score", htf_align ? 1 : 0, "number") + ',' +
        '"metadata":{' +
            '"htf_mid":' + (not na(htf_mid_val) ? sanitize_number(format_price(htf_mid_val)) : "null") + ',' +
            emit_field_prim("session", sessionName, "string") + ',' +
            emit_field_prim("side", side, "string") + ',' +
            emit_field_prim("thresholds_used", "HTF mid", "string") + ',' +
            emit_field_prim("value_reason", htf_align ? "HTF aligned" : "Not aligned", "string") +
        '}' +
    '}')
    // KILLZONE
    array.push(rule_provenance, '{' +
        emit_field_prim("rule", "KILLZONE", "string") + ',' +
        emit_field_prim("value", killzone_active, "bool") + ',' +
        emit_field_prim("score", killzone_active ? 1 : 0, "number") + ',' +
        '"metadata":{' +
            emit_field_prim("session", sessionName, "string") + ',' +
            emit_field_prim("side", side, "string") + ',' +
            emit_field_prim("thresholds_used", "Session times", "string") + ',' +
            emit_field_prim("value_reason", killzone_active ? "In killzone" : "Not in killzone", "string") +
        '}' +
    '}')

    // --- Weighted confidence ---
    confidence = get_weighted_confidence(htf_align, ob_match, fvg_match, sweep_val, killzone_active)
    confidence_method = "weighted_v1"
    bar_time = get_bar_time()
    created_at = get_created_at()
    signal_id = get_signal_id(side)
    idx = bar_index
    // --- Build enriched POI array ---
    poi_arr = array.new_string()
    created_bar_time = get_bar_time()
    if side == "BUY"
        for i = 0 to safe_max_idx(bullish_ob_top, array.size(bullish_ob_top) - 1)
            ob_top = safe_get(bullish_ob_top, i, na)
            ob_btm = safe_get(bullish_ob_btm, i, na)
            ob_time = safe_get(bullish_ob_loc, i, na)
            if not na(ob_top) and not na(ob_btm) and not na(ob_time)
                array.push(poi_arr, build_ob("BUY", ob_top, ob_btm, ob_top, ob_btm, ob_time))
        for i = 0 to safe_max_idx(bFVG_UP_top, array.size(bFVG_UP_top) - 1)
            poi_id = get_poi_id(syminfo.ticker, timeframe.period, created_bar_time, i)
            array.push(poi_arr, poi_obj(
                safe_get(bFVG_UP_top, i, na),
                safe_get(bFVG_UP_btm, i, na),
                safe_get(bFVG_UP_left, i, na),
                n, n, my_pip_size,
                true, safe_get(bFVG_UP_left, i, na),
                "FVG",
                poi_id
            ))
    else if side == "SELL"
        for i = 0 to safe_max_idx(bearish_ob_top, array.size(bearish_ob_top) - 1)
            ob_top = safe_get(bearish_ob_top, i, na)
            ob_btm = safe_get(bearish_ob_btm, i, na)
            ob_time = safe_get(bearish_ob_loc, i, na)
            if not na(ob_top) and not na(ob_btm) and not na(ob_time)
                array.push(poi_arr, build_ob("SELL", ob_top, ob_btm, ob_top, ob_btm, ob_time))
        for i = 0 to safe_max_idx(bFVG_DN_top, array.size(bFVG_DN_top) - 1)
            poi_id = get_poi_id(syminfo.ticker, timeframe.period, created_bar_time, i)
            array.push(poi_arr, poi_obj(
                safe_get(bFVG_DN_top, i, na),
                safe_get(bFVG_DN_btm, i, na),
                safe_get(bFVG_DN_left, i, na),
                n, n, my_pip_size,
                true, safe_get(bFVG_DN_left, i, na),
                "FVG",
                poi_id
            ))
    poi_json_str = "[" + array.join(poi_arr, ",") + "]"
    // --- Structured entry ---
    entry_type = "close"  // can be extended to "limit"/"midpoint" as needed
    entry_trigger = side == "BUY" and array.size(bFVG_UP_top) > 0 ? "retrace_fvg" : side == "SELL" and array.size(bFVG_DN_top) > 0 ? "retrace_fvg" : array.size(bullish_ob_top) > 0 or array.size(bearish_ob_top) > 0 ? "ob_tap" : "break_retest"
    entry_confirmation = ta.candlecolor(0) == color.green and ta.candlecolor(1) == color.red ? "engulf" : ta.candlecolor(0) == color.green and ta.lowest(low, 3) == low ? "pinbar" : "none"
    entry_json = entry_obj(entry, entry_type, entry_trigger, entry_confirmation)

    // --- SL: Reference OB or FVG edge ---
    sl_type = "zone_bottom"
    sl_zone_id = ""
    sl_val = na
    if side == "BUY" and array.size(bullish_ob_btm) > 0
    sl_val := safe_get(bullish_ob_btm, 0, na)
        sl_zone_id := "POI_" + syminfo.ticker + "_" + timeframe.period + "_" + str.tostring(bar_time) + "_OB_0"
    else if side == "BUY" and array.size(bFVG_UP_btm) > 0
    sl_val := safe_get(bFVG_UP_btm, 0, na)
        sl_zone_id := "POI_" + syminfo.ticker + "_" + timeframe.period + "_" + str.tostring(bar_time) + "_FVG_0"
    else if side == "SELL" and array.size(bearish_ob_top) > 0
    sl_val := safe_get(bearish_ob_top, 0, na)
        sl_zone_id := "POI_" + syminfo.ticker + "_" + timeframe.period + "_" + str.tostring(bar_time) + "_OB_0"
    else if side == "SELL" and array.size(bFVG_DN_top) > 0
    sl_val := safe_get(bFVG_DN_top, 0, na)
        sl_zone_id := "POI_" + syminfo.ticker + "_" + timeframe.period + "_" + str.tostring(bar_time) + "_FVG_0"
    sl_json = sl_obj(sl_val, sl_type, sl_zone_id)

    // --- TP: Reference liquidity pools, HTF levels, or multiple POIs ---
    use_multi_tp = true  // can be toggled/configured
    tp_arr = array.new_string()
    // Add liquidity pool as TP
    if side == "BUY" and array.size(b_liq_B_top) > 0
    array.push(tp_arr, tp_obj(safe_get(b_liq_B_top, 0, na), "liq_pool", "POI_" + syminfo.ticker + "_" + timeframe.period + "_" + str.tostring(bar_time) + "_LIQ_B_0"))
    if side == "SELL" and array.size(b_liq_S_btm) > 0
    array.push(tp_arr, tp_obj(safe_get(b_liq_S_btm, 0, na), "liq_pool", "POI_" + syminfo.ticker + "_" + timeframe.period + "_" + str.tostring(bar_time) + "_LIQ_S_0"))
    // Add HTF mid as TP
    if not na(htf_mid_val)
        array.push(tp_arr, tp_obj(htf_mid_val, "htf_mid", "POI_" + syminfo.ticker + "_" + timeframe.period + "_" + str.tostring(bar_time) + "_HTF_MID"))
    // Add FVG as TP
    if side == "BUY" and array.size(bFVG_UP_top) > 0
    array.push(tp_arr, tp_obj(safe_get(bFVG_UP_top, 0, na), "fvg", "POI_" + syminfo.ticker + "_" + timeframe.period + "_" + str.tostring(bar_time) + "_FVG_UP_0"))
    if side == "SELL" and array.size(bFVG_DN_btm) > 0
    array.push(tp_arr, tp_obj(safe_get(bFVG_DN_btm, 0, na), "fvg", "POI_" + syminfo.ticker + "_" + timeframe.period + "_" + str.tostring(bar_time) + "_FVG_DN_0"))
    tp_json_str = "[" + array.join(tp_arr, ",") + "]"
    // --- Deterministic idempotency_key for backend deduplication ---
    idempotency_key = signal_id + "|" + detector_version
    // --- Primitive required field validation ---
    invalid = not is_valid_signal(signal_id, entry, sl, tp)
    // --- Defensive fields_present and notes ---
    fields_present = array.new_string()
    notes = ""
    // List all fields and check for na
    // Minimal mode fields
    if not na(signal_id)
        array.push(fields_present, "signal_id")
    if not na(created_at)
        array.push(fields_present, "created_at")
    if not na(syminfo.ticker)
        array.push(fields_present, "symbol")
    if not na(timeframe.period)
        array.push(fields_present, "tf")
    if not na(side)
        array.push(fields_present, "side")
    if not na(entry)
        array.push(fields_present, "entry")
    if not na(sl)
        array.push(fields_present, "sl")
    if not na(tp)
        array.push(fields_present, "tp")
    if not na(detector_version)
        array.push(fields_present, "detector_version")
    if not na(idempotency_key)
        array.push(fields_present, "idempotency_key")
    // Full mode extra fields
    if not minimal_mode
        if not na(pine_version)
            array.push(fields_present, "pine_version")
        if not na(bar_time)
            array.push(fields_present, "bar_time")
        if not na(idx)
            array.push(fields_present, "bar_index")
        if not na(score)
            array.push(fields_present, "score")
        if not na(score_breakdown_obj)
            array.push(fields_present, "score_breakdown")
        if not na(confidence)
            array.push(fields_present, "confidence")
        if not na(confidence_method)
            array.push(fields_present, "confidence_method")
        if not na(sessionName)
            array.push(fields_present, "session")
        if not na(htf_mid_val)
            array.push(fields_present, "htf_mid")
        else
            notes := notes + "htf_mid unavailable: insufficient history; "
        if not na(regime)
            array.push(fields_present, "regime")
        if not na(choch_up)
            array.push(fields_present, "choch_up")
        if not na(choch_down)
            array.push(fields_present, "choch_down")
        if not na(bos_up)
            array.push(fields_present, "bos_up")
        if not na(bos_down)
            array.push(fields_present, "bos_down")
        if not na(poi_json_str)
            array.push(fields_present, "poi")

    // --- Emit fields_present as valid JSON array of quoted strings ---
    fields_present_json = array.size(fields_present) == 0 ? "[]" : '["' + array.join(fields_present, '","') + '"]'

    // --- Build JSON payload deterministically ---
    full_payload = invalid ? "{}" : (
        "{" +
        emit_field_prim("schema_version", schema_version, "string") + "," +
        emit_field_prim("signal_id", signal_id, "string") + "," +
        emit_field_prim("idempotency_key", idempotency_key, "string") + "," +
        emit_field_prim("detector_version", detector_version, "string") +
        (not minimal_mode ? "," + emit_field_prim("pine_version", pine_version, "string") : "") +
        "," + emit_field_prim("created_at", created_at, "string") +
        (not minimal_mode ? "," + emit_field_prim("bar_time", bar_time, "number") : "") +
        (not minimal_mode ? "," + emit_field_prim("bar_index", idx, "number") : "") +
        "," + emit_field_prim("symbol", syminfo.ticker, "string") +
        "," + emit_field_prim("tf", timeframe.period, "string") +
        "," + emit_field_prim("side", side, "string") +
        (not minimal_mode ? "," + emit_field_prim("score", score, "number") : "") +
        (not minimal_mode ? "," + emit_field_str("score_breakdown", safe_get(score_breakdown_obj, "score_breakdown")) : "") +
        (not minimal_mode ? "," + emit_field_prim("confidence", confidence, "number") : "") +
        (not minimal_mode ? "," + emit_field_prim("confidence_method", confidence_method, "string") : "") +
        "," + emit_field_str("entry", entry_json) +
        "," + emit_field_str("sl", sl_json) +
        "," + emit_field_str("tp", tp_json_str) +
        (not minimal_mode ? "," + emit_field_prim("session", sessionName, "string") : "") +
        (not minimal_mode ? "," + '"htf_mid":' + (not na(htf_mid_val) ? sanitize_number(format_price(htf_mid_val)) : "null") : "") +
        (not minimal_mode ? "," + emit_field_prim("regime", regime, "number") : "") +
        (not minimal_mode ? "," + emit_field_prim("choch_up", choch_up, "bool") : "") +
        (not minimal_mode ? "," + emit_field_prim("choch_down", choch_down, "bool") : "") +
        (not minimal_mode ? "," + emit_field_prim("bos_up", bos_up, "bool") : "") +
        (not minimal_mode ? "," + emit_field_prim("bos_down", bos_down, "bool") : "") +
        (not minimal_mode ? "," + emit_field_str("poi", poi_json_str) : "") +
        "," + emit_field_str("fields_present", fields_present_json) +
        (notes != "" ? ',"notes":"' + notes + '"' : "") +
    (legacy_mode ? ',"deprecation_note":"Legacy mode enabled. These fields will be removed in the next major version.","entry_price":' + (not na(entry) ? format_price(entry) : "null") + ',"sl_price":' + (not na(sl) ? format_price(sl) : "null") + ',"tp_price":' + (not na(tp) ? format_price(tp) : "null") : "")
    + ',"rule_provenance":[' + array.join(rule_provenance, ",") + ']'
    + "}"
    )
    // Minimal payload if too large
    minimal_fetch_url = "https://enrich.mybackend.com/signal/" + signal_id
    minimal_payload = '{' +
        '"signal_id":' + sanitize_string(signal_id) + ',' +
        '"entry":' + safe_get(entry_json, "entry") + ',' +
        '"sl":' + safe_get(sl_json, "sl") + ',' +
        '"tp":' + safe_get(tp_json_str, "tp") + ',' +
        '"detector_version":' + sanitize_string(detector_version) + ',' +
        emit_field_prim("fetch_url", minimal_fetch_url, "string") + ',' +
        emit_field_prim("fetch_token", idempotency_key, "string") +
    '}'
    payload = (str.length(full_payload) > 2000) ? minimal_payload : full_payload
    payload
// 6. Minimal Payload Mode: If enabled, only essential fields are sent; backend can enrich using signal_id.
// ============================================================================
// === PRODUCTION CONTROLS EXTENSION: VERSIONING & IDEMPOTENCY ===
detector_version = "v1.2.0"
pine_version = "Hybrid ICT Trading System [Pro]"

// === PRODUCTION CONTROLS: LEGACY SCHEMA MODE (DEPRECATED) ===
// Legacy mode will be removed in next major version.
legacy_mode = input.bool(false, "Legacy Mode (deprecated)", group="Production Controls")

// ============================================================================
// CHANGELOG.md (INLINE)
// ----------------------------------------------------------------------------
// detector_version: v1.2.0
// - 2025-09-15: Add inline README and CHANGELOG documentation.
// - v1.2.0: Schema versioning (v2), legacy mode, rule_provenance, fields_present, notes, test harness, debug counters, security hardening, price formatting, minimal mode, and full production controls.
// - v1.1.x: Robust error handling, logging, alert gating, and async-safe JSON.
// - v1.1.0: Deterministic idempotency, POI geometry, structured entry/sl/tp, score breakdown, normalized confidence.
// - v1.0.0: Initial production release, SMC/ICT logic, webhook JSON, killzone/session gating, Telegram/AI integration.
// ----------------------------------------------------------------------------
// Always ensure detector_version in code matches this changelog.
// ============================================================================
// Deterministic idempotency key: hash(signal_id + detector_version)
hash_concat(str1, str2) =>
    // Simple deterministic hash: sum of char codes mod 1e9
    s = str1 + str2
    h = 0
    for i = 0 to str.length(s) - 1
        h := h + str.tonumber(str.char(s, i))
    str.tostring(h % 1000000000)
/*
===============================================================================
PRODUCTION CONTROL LAYER (SAFE BY DEFAULT)
-------------------------------------------------------------------------------
This script is safe for development and backtesting by default.
To enable live webhook alerts, set Environment Mode to "prod" and Enable Alerts to true.
Otherwise, alerts will never fire and only debug labels will appear.
All original logic, plots, and outputs are preserved.
===============================================================================
*/

//==============================
// PRODUCTION CONTROLS SECTION
//==============================

// === PRODUCTION CONTROLS: PAYLOAD SIZE SAFEGUARD & MINIMAL MODE ===
// Minimal Payload Mode: emits only essential fields for backend enrichment
minimal_mode = input.bool(false, "Minimal Payload Mode", group="Production Controls")

// TradingView alert() payload limit is 2000 chars. Minimal mode ensures compact JSON.
// If minimal_mode is enabled, backend should fetch enrichment using signal_id.

// === PRODUCTION CONTROLS: PRICE PRECISION & FORMATTING ===
// Set price_precision by instrument type
var int price_precision = na
if barstate.isfirst
    if syminfo.type == "forex"
        price_precision := 5
    else if str.contains(syminfo.ticker, "XAUUSD") or syminfo.type == "index"
        price_precision := 2
    else if syminfo.type == "crypto"
        price_precision := 8
    else
        price_precision := 2  // default fallback

// Helper to format price with correct decimals
format_price(val) =>
    decs = price_precision
    fmt = "#." + str.repeat("0", decs)
    str.tostring(val, fmt)
// Environment Mode (dev, staging, prod)
env_mode = input.string("dev", "Environment Mode", options=["dev","staging","prod"], group="Production Controls")
enableProdAlerts = input.bool(false, "Enable Alerts", group="Production Controls")

// Centralized debug mode enforcement
var bool _debug_mode = na
if env_mode == "dev"
    _debug_mode := true
else if env_mode == "prod"
    _debug_mode := false
else
    _debug_mode := debug_mode  // fallback to user input for staging

// Centralized alert gating
can_fire_alerts = (env_mode == "prod") and enableProdAlerts

// Centralized error log (comment-based)
var string _error_log = ""
log_error(msg) =>
    _error_log := str.tostring(time) + ": " + msg + "\n" + _error_log

// Centralized risk/discipline controls (future-proof)
max_alerts_per_day = max_daily_signals  // already present
min_confluence_required = min_confluence

// Future-proof: backend signal schema versioning
signal_schema_version = "1.0.0"

// Table output for error log (optional, can be toggled)
show_error_log = input.bool(false, "Show Error Log Table", group="Production Controls")
if show_error_log and barstate.islast
    var table err_table = table.new(position.bottom_right, 1, 10, bgcolor=color.new(color.red, 90))
    for i = 0 to math.min(9, str.lines(_error_log) - 1)
        table.cell(err_table, 0, i, str.line(_error_log, i), text_color=color.white, text_size=size.tiny)

//@version=5
indicator("Hybrid ICT Trading System [Pro]", overlay=true, max_labels_count=500, max_lines_count=500, max_boxes_count=500, max_bars_back=3000)
//=============================================================================
// RESTORE: OB open buffer input and premium/discount zone logic (pre-refactor compatibility)
//=============================================================================

// OB open buffer (missing input)
ob_open_buffer_ticks = input.int(2, title="OB Open Buffer (ticks)", group="Order Blocks", minval=1, maxval=10)

// Premium/Discount zones (legacy logic for retracement/zone gating)
daily_low_24 = ta.lowest(low, 24)
daily_high_24 = ta.highest(high, 24)
daily_range = daily_high_24 - daily_low_24
premium_zone = daily_range > 0 ? daily_low_24 + (daily_range * 0.75) : high
discount_zone = daily_range > 0 ? daily_low_24 + (daily_range * 0.25) : low

//=============================================================================
// INPUTS - Combined from both systems
//=============================================================================


// Market Structure & Signal Generation
grp1 = "Market Structure & Signals"
swing_length = input.int(5, title="Swing Detection Length", group=grp1, minval=3, maxval=10)
showMS = input.bool(true, title="Show Market Structure", group=grp1)
iMSS = input.bool(true, title="Show MSS", group=grp1, inline="mss")
cMSSbl = input.color(color.new(#00e6a1, 0), title="Bull", group=grp1, inline="mss")
cMSSbr = input.color(color.new(#e60400, 0), title="Bear", group=grp1, inline="mss")
iBOS = input.bool(true, title="Show BOS", group=grp1, inline="bos")
cBOSbl = input.color(color.new(#00e6a1, 0), title="Bull", group=grp1, inline="bos")
cBOSbr = input.color(color.new(#e60400, 0), title="Bear", group=grp1, inline="bos")

// CHANGE #toggle-choch: new input to enforce CHoCH before regime flip
require_choch_for_flip = input.bool(true, "Require CHoCH for Bias Flip", group=grp1)


// Signal Generation Controls
grp2 = "Signal Generation"
max_daily_signals = input.int(5, title="Max Signals Per Day", group=grp2, minval=1, maxval=20)
cooldown_bars = input.int(10, title="Signal Cooldown (bars)", group=grp2, minval=1)
min_confluence = input.int(4, title="Minimum Confluence Score", group=grp2, minval=2, maxval=8)
enable_alerts = input.bool(true, title="Enable Trading Alerts", group=grp2)
// CHANGE #debug-mode: do not fire real alerts while verifying
debug_mode = input.bool(true, "Debug Mode (no real alerts)", group=grp2, tooltip="When ON, alerts are printed to labels/table only")

// Sessions & Killzones
grp3 = "Sessions & Killzones"
showKZ = input.bool(true, title="Show Killzones", group=grp3)
// CHANGE #sessions: robust session strings (NY time)
session_lo_str = input.session("0200-0500", "London Killzone (NYT)", group=grp3)
session_ny_str = input.session("0730-1030", "New York Killzone (NYT)", group=grp3)
showNy = input.bool(true, title="New York", group=grp3, inline="ny") and showKZ
nyCss = input.color(color.new(#ff5d00, 93), title="", group=grp3, inline="ny")
showLdno = input.bool(true, title="London Open", group=grp3, inline="lo") and showKZ
ldnoCss = input.color(color.new(#00bcd4, 93), title="", group=grp3, inline="lo")
// CHANGE #legacy-offset: keep for compatibility but no longer used for gating
session_tz_offset = input.int(-5, title="Timezone Offset (legacy, unused for gating)", group=grp3, tooltip="Kept for compatibility with backgrounds only")

// Fair Value Gaps
grp4 = "Fair Value Gaps"
shwFVG = input.bool(true, title="Show FVGs", group=grp4)
fvg_min_pips = input.int(10, title="Min FVG Size (pips)", group=grp4, minval=1)
visBxs = input.int(3, title="Visible FVGs", group=grp4, minval=1, maxval=10)
cFVGbl = input.color(color.new(#00e676, 75), title="Bullish FVG", group=grp4, inline="fvgb")
cFVGblBR = input.color(color.new(#808000, 85), title="Break", group=grp4, inline="fvgb")
cFVGbr = input.color(color.new(#ff5252, 75), title="Bearish FVG", group=grp4, inline="fvgr")
cFVGbrBR = input.color(color.new(#FF0000, 85), title="Break", group=grp4, inline="fvgr")

// Order Blocks
grp5 = "Order Blocks"
showOB = input.bool(true, title="Show Order Blocks", group=grp5)
ob_length = input.int(10, title="OB Swing Lookback", group=grp5, minval=3)
showBull = input.int(2, title="Show Bullish OBs", group=grp5, minval=0, maxval=5)
showBear = input.int(2, title="Show Bearish OBs", group=grp5, minval=0, maxval=5)
useBody = input.bool(true, title="Use Candle Body", group=grp5)
bullCss = input.color(color.new(#3e89fa, 75), title="Bullish OB", group=grp5, inline="ob1")
bullBrkCss = input.color(color.new(#4785f9, 85), title="Break", group=grp5, inline="ob1")
bearCss = input.color(color.new(#FF3131, 75), title="Bearish OB", group=grp5, inline="ob2")
bearBrkCss = input.color(color.new(#f9ff57, 85), title="Break", group=grp5, inline="ob2")

// Liquidity
grp6 = "Liquidity"
showLq = input.bool(true, title="Show Liquidity", group=grp6)
liq_margin = input.float(4, title="Liquidity Margin", group=grp6, step=0.1, minval=2, maxval=7)
visLiq = input.int(3, title="Visible Liquidity Boxes", group=grp6, minval=1, maxval=10)
cLIQ_B = input.color(color.new(#fa451c, 75), title="Buyside", group=grp6, inline="liq")
cLIQ_S = input.color(color.new(#1ce4fa, 75), title="Sellside", group=grp6, inline="liq")


// HTF Context Gating
htf_tf = input.string("60", title="HTF for Bias", group="Signal Generation", options=["15", "30", "60", "240", "1D"])

// CHANGE #sweep-inputs: sweep window for reclose
sweep_candles = input.int(2, "Sweep Close-back Window (bars)", group="Signal Generation", minval=1, maxval=3, tooltip="Sweep must close back inside within N bars")

//=============================================================================
// CORE VARIABLES
//=============================================================================


// Core calculations
n = bar_index
tf_msec = timeframe.in_seconds(timeframe.period) * 1000
my_pip_size = syminfo.type == "forex" ? (syminfo.mintick * 10) : syminfo.mintick
atr = ta.atr(14)

// === PRODUCTION CONTROLS: SAFE per GUARD ===
perBars = 1000
var int last_bar_index = na
if barstate.islast
    last_bar_index := bar_index
// per: true if within last perBars bars, always true if last_bar_index is na (early bars)
per = na(last_bar_index) ? true : bar_index >= (last_bar_index - perBars)
maxSize = 20  // Reduced for performance


// Displacement and volatility filters
body_size = math.abs(close - open)
// CHANGE #disp-relax: relax displacement per body dominance + ATR multiple
true_range = high - low // CHANGE #disp-relax
body_ratio_ok = true_range > 0 and (body_size / true_range) >= 0.6 // CHANGE #disp-relax
disp_ok = body_size >= 0.5 * atr and body_ratio_ok // CHANGE #disp-relax
is_displacement = disp_ok // CHANGE #disp-relax: preserve old name

min_atr = my_pip_size * 10
vol_ok = atr > min_atr


// HTF Context - Replaced SMA with HTF PD mid
// CHANGE #htf-mid: compute HTF mid from prev HTF H/L
htf_prevH = request.security(syminfo.tickerid, htf_tf, high[1], lookahead=barmerge.lookahead_off)
htf_prevL = request.security(syminfo.tickerid, htf_tf, low[1],  lookahead=barmerge.lookahead_off)
htf_mid = (htf_prevH + htf_prevL) / 2.0 // CHANGE #htf-mid
htf_bull = close > htf_mid               // CHANGE #htf-mid: preserve variable names
htf_bear = close < htf_mid               // CHANGE #htf-mid

//=============================================================================
// ARRAY DECLARATIONS
//=============================================================================

// Order Blocks
var bullish_ob_top = array.new<float>()
var bullish_ob_btm = array.new<float>()
var bullish_ob_loc = array.new<int>()
var bullish_ob_breaker = array.new<bool>()

var bearish_ob_top = array.new<float>()
var bearish_ob_btm = array.new<float>()
var bearish_ob_loc = array.new<int>()
var bearish_ob_breaker = array.new<bool>()

// FVGs
var bFVG_UP_active = array.new<bool>()
var bFVG_UP_top = array.new<float>()
var bFVG_UP_btm = array.new<float>()
var bFVG_UP_left = array.new<int>()

var bFVG_DN_active = array.new<bool>()
var bFVG_DN_top = array.new<float>()
var bFVG_DN_btm = array.new<float>()
var bFVG_DN_left = array.new<int>()

// Liquidity
var b_liq_B_top = array.new<float>()
var b_liq_B_btm = array.new<float>()
var b_liq_B_left = array.new<int>()
var b_liq_B_broken = array.new<bool>()

var b_liq_S_top = array.new<float>()
var b_liq_S_btm = array.new<float>()
var b_liq_S_left = array.new<int>()
var b_liq_S_broken = array.new<bool>()



// Market Structure
// Legacy: Market Structure Direction (flagged for deprecation)
var int MSS_dir = na
var pivot_highs = array.new<float>()
var pivot_lows = array.new<float>()
var pivot_high_bars = array.new<int>()
var pivot_low_bars = array.new<int>()

// CHANGE #structure-vars: explicit last swings + regime + events
var float lastSwingHigh = na
var float lastSwingLow  = na
var int   regime = 0 // 1=bull, -1=bear, 0=neutral
var bool bos_up = false
var bool bos_down = false
var bool choch_up = false
var bool choch_down = false
var bool sweep_against_short = false
var bool sweep_against_long = false


//=============================================================================
// SESSION DETECTION (Replaced with input.session)
//=============================================================================

// CHANGE #sessions: robust session detection; keep names used elsewhere
is_weekday = dayofweek(time) >= dayofweek.monday and dayofweek(time) <= dayofweek.friday
in_lo = not na(time(timeframe.period, session_lo_str)) and is_weekday
in_ny = not na(time(timeframe.period, session_ny_str)) and is_weekday
is_london_session = in_lo // keep legacy var names
is_ny_session = in_ny
killzone_active = is_london_session or is_ny_session

//=============================================================================
// SIGNAL TRACKING
//=============================================================================

var int signal_count_today = 0
var int last_signal_bar = na


//=============================================================================
// UTILITY FUNCTIONS
//=============================================================================

// --- SAFE ARRAY ACCESS HELPERS (PRODUCTION CONTROLS) ---
safe_get(arr, idx, default_val) =>
    idx >= 0 and idx < array.size(arr) ? array.get(arr, idx) : default_val // Only allowed direct array.get usage

safe_max_idx(arr, n) =>
    math.min(n, array.size(arr) - 1)

// Legacy: calculate_confluence() is deprecated and only runs if legacy_mode is enabled
calculate_confluence() =>
    legacy_mode ? (
        int score = 0
        if MSS_dir == 1
            score += 1
        if MSS_dir == -1
            score += 1
        has_active_fvg_up = false
        has_active_fvg_dn = false
        if array.size(bFVG_UP_active) > 0
            for i = 0 to safe_max_idx(bFVG_UP_active, 2)
                if safe_get(bFVG_UP_active, i, false)
                    has_active_fvg_up := true
                    break
        if array.size(bFVG_DN_active) > 0
            for i = 0 to safe_max_idx(bFVG_DN_active, 2)
                if safe_get(bFVG_DN_active, i, false)
                    has_active_fvg_dn := true
                    break
        if has_active_fvg_up or has_active_fvg_dn
            score += 1
        if array.size(bullish_ob_top) > 0 or array.size(bearish_ob_top) > 0
            score += 1
        if array.size(b_liq_B_top) > 0
            score += 1
        if array.size(b_liq_S_top) > 0
            score += 1
        if killzone_active
            score += 1
        if in_premium or in_discount
            score += 1
        score
    ) : na

// CHANGE #side-confluence: side-aware scoring per your rules
// Sweep detection flags (safe guarded assignment)
if array.size(b_liq_S_btm) > 0
    sweep_against_long := (low < safe_get(b_liq_S_btm, 0, na) and close > safe_get(b_liq_S_btm, 0, na))
else
    sweep_against_long := false

if array.size(b_liq_B_top) > 0
    sweep_against_short := (high > safe_get(b_liq_B_top, 0, na) and close < safe_get(b_liq_B_top, 0, na))
else
    sweep_against_short := false

confluence_for_side(isLong) =>
    int s = 0
    // HTF alignment via mid
    if (isLong and htf_bull) or ((not isLong) and htf_bear)
        s += 1

    // Structure events
    if isLong
        if regime == 1 or choch_up or bos_up
            s += 1
    else
        if regime == -1 or choch_down or bos_down
            s += 1

    // Active FVG alignment
    has_up_fvg = array.size(bFVG_UP_active) > 0 and safe_get(bFVG_UP_active, 0, false)
    has_dn_fvg = array.size(bFVG_DN_active) > 0 and safe_get(bFVG_DN_active, 0, false)
    if (isLong and has_up_fvg) or ((not isLong) and has_dn_fvg)
        s += 1

    // OB presence alignment
    if isLong and array.size(bullish_ob_top) > 0
        s += 1
    if not isLong and array.size(bearish_ob_top) > 0
        s += 1

    // PD mid alignment (prior-day)
    // Use precomputed pd_mid
    in_premium_ = close >= prevD_mid_
    in_discount_ = close <= prevD_mid_
    if (isLong and in_discount_) or ((not isLong) and in_premium_)
        s += 1

    // Sweep alignment: want sweep against direction before entry
    if isLong
        if nz(sweep_against_long, false)
            s += 1
    else
        if nz(sweep_against_short, false)
            s += 1

    // Killzone
    if killzone_active
        s += 1

    // Volatility/Displacement
    if vol_ok and is_displacement
        s += 1

    s

//=============================================================================
// MARKET STRUCTURE DETECTION
//=============================================================================

// Simplified pivot detection
ph = ta.pivothigh(high, swing_length, 1)
pl = ta.pivotlow(low, swing_length, 1)

if not na(ph)
    array.unshift(pivot_highs, ph)
    array.unshift(pivot_high_bars, bar_index[1])
    if array.size(pivot_highs) > 5
        array.pop(pivot_highs)
        array.pop(pivot_high_bars)

if not na(pl)
    array.unshift(pivot_lows, pl)
    array.unshift(pivot_low_bars, bar_index[1])
    if array.size(pivot_lows) > 5
        array.pop(pivot_lows)
        array.pop(pivot_low_bars)


// Market Structure Direction (legacy trend-ish for display only)
if array.size(pivot_highs) >= 2 and array.size(pivot_lows) >= 2
    recent_high = safe_get(pivot_highs, 0, na)
    prev_high = safe_get(pivot_highs, 1, na)
    recent_low = safe_get(pivot_lows, 0, na)
    prev_low = safe_get(pivot_lows, 1, na)

    if recent_high > prev_high and recent_low > prev_low
        MSS_dir := 1  // Bullish
    else if recent_high < prev_high and recent_low < prev_low
        MSS_dir := -1  // Bearish

// CHANGE #structure-events: update last swings and detect BOS/CHoCH
if not na(ph)
    lastSwingHigh := ph
if not na(pl)
    lastSwingLow := pl

bos_up := not na(lastSwingHigh) and close > lastSwingHigh
bos_down := not na(lastSwingLow) and close < lastSwingLow

choch_up := regime == -1 and bos_up
choch_down := regime == 1 and bos_down

// Regime update
if require_choch_for_flip
    if choch_up
        regime := 1
    else if choch_down
        regime := -1
else
    if choch_up or bos_up
        regime := 1
    else if choch_down or bos_down
        regime := -1

// Optional plotting for structure events
plotshape(iBOS and bos_up,   title="BOS ↑", style=shape.triangleup,   location=location.belowbar, color=cBOSbl, size=size.tiny, text="BOS↑")
plotshape(iBOS and bos_down, title="BOS ↓", style=shape.triangledown, location=location.abovebar, color=cBOSbr, size=size.tiny, text="BOS↓")
plotshape(iMSS and choch_up,   title="CHoCH ↑", style=shape.labelup,   location=location.belowbar, color=cMSSbl, size=size.tiny, text="CHoCH↑")
plotshape(iMSS and choch_down, title="CHoCH ↓", style=shape.labeldown, location=location.abovebar, color=cMSSbr, size=size.tiny, text="CHoCH↓")

//=============================================================================

// === CANONICAL FVG DETECTION ===
if barstate.isfirst
    for i = 0 to visBxs - 1
        array.push(bFVG_UP_active, false)
        array.push(bFVG_UP_top, na)
        array.push(bFVG_UP_btm, na)
        array.push(bFVG_UP_left, na)
        array.push(bFVG_DN_active, false)
        array.push(bFVG_DN_top, na)
        array.push(bFVG_DN_btm, na)
        array.push(bFVG_DN_left, na)

var boxes_fvg_up = array.new_box()
var boxes_fvg_dn = array.new_box()

// Use canonical FVG builder and manage boxes
build_fvg(true, n, high, low, open, close, meanBody, swing_length, fvg_min_pips, my_pip_size, per, shwFVG, visBxs, cFVGbl, boxes_fvg_up)
manage_poi_boxes(bFVG_UP_top, bFVG_UP_btm, bFVG_UP_left, n, boxes_fvg_up, cFVGbl, visBxs)
build_fvg(false, n, high, low, open, close, meanBody, swing_length, fvg_min_pips, my_pip_size, per, shwFVG, visBxs, cFVGbr, boxes_fvg_dn)
manage_poi_boxes(bFVG_DN_top, bFVG_DN_btm, bFVG_DN_left, n, boxes_fvg_dn, cFVGbr, visBxs)

// CHANGE #fvg-mitigate-mid: consider mitigated at 50%
fvg_mid_dn(idx) =>
fvg_mid_up(idx) =>
    top = safe_get(bFVG_UP_top, idx, na)
    btm = safe_get(bFVG_UP_btm, idx, na)
    (top + btm) / 2.0

fvg_mid_dn(idx) =>
    top = safe_get(bFVG_DN_top, idx, na)
    btm = safe_get(bFVG_DN_btm, idx, na)
    (top + btm) / 2.0

// Update active state by mid fill; update boxes idempotently
if array.size(bFVG_UP_active) > 0
    for i = 0 to safe_max_idx(bFVG_UP_active, visBxs - 1)
        if safe_get(bFVG_UP_active, i, false)
            midv = fvg_mid_up(i)
            if not na(midv) and low <= midv
                array.set(bFVG_UP_active, i, false)
        // Update box right edge + color
        if i < array.size(boxes_fvg_up)
            bx = safe_get(boxes_fvg_up, i, na)
            if not na(bx)
                box.set_right(bx, bar_index)
                active = safe_get(bFVG_UP_active, i, false)
                box.set_bgcolor(bx, active ? cFVGbl : cFVGblBR)

if array.size(bFVG_DN_active) > 0
    for i = 0 to safe_max_idx(bFVG_DN_active, visBxs - 1)
        if safe_get(bFVG_DN_active, i, false)
            midv2 = fvg_mid_dn(i)
            if not na(midv2) and high >= midv2
                array.set(bFVG_DN_active, i, false)
        if i < array.size(boxes_fvg_dn)
            bx2 = safe_get(boxes_fvg_dn, i, na)
            if not na(bx2)
                box.set_right(bx2, bar_index)
                active2 = safe_get(bFVG_DN_active, i, false)
                box.set_bgcolor(bx2, active2 ? cFVGbr : cFVGbrBR)

//=============================================================================
// ORDER BLOCKS (Simplified + idempotent drawing)
//=============================================================================


// === CANONICAL OB ARRAYS AND BOX MANAGEMENT ===
var boxes_ob_bull = array.new_box()
var boxes_ob_bear = array.new_box()

if not na(ph) and showOB and per
    // Bullish OB on new high
    if array.size(pivot_highs) > 1 and ph > safe_get(pivot_highs, 1, na)
        ob_json = build_ob("BUY", open[1], close[1], high[1], low[1], time[1])
        ob_obj = json.parse(ob_json)
        ob_high = ob_obj.top
        ob_low = ob_obj.bottom
        array.unshift(bullish_ob_top, ob_high)
        array.unshift(bullish_ob_btm, ob_low)
        array.unshift(bullish_ob_loc, time[1])
        array.unshift(bullish_ob_breaker, false)
        while array.size(bullish_ob_top) > showBull
            array.pop(bullish_ob_top)
            array.pop(bullish_ob_btm)
            array.pop(bullish_ob_loc)
            array.pop(bullish_ob_breaker)
        // Box management
        b = box.new(time[1], ob_high, time + tf_msec * 2, ob_low, xloc=xloc.bar_time, bgcolor=bullCss, border_color=color.new(color.white, 100))
        array.unshift(boxes_ob_bull, b)
        if array.size(boxes_ob_bull) > showBull
            box.delete(array.pop(boxes_ob_bull))

if not na(pl) and showOB and per
    // Bearish OB on new low
    if array.size(pivot_lows) > 1 and pl < safe_get(pivot_lows, 1, na)
        ob_json = build_ob("SELL", open[1], close[1], high[1], low[1], time[1])
        ob_obj = json.parse(ob_json)
        ob_high = ob_obj.top
        ob_low = ob_obj.bottom
        array.unshift(bearish_ob_top, ob_high)
        array.unshift(bearish_ob_btm, ob_low)
        array.unshift(bearish_ob_loc, time[1])
        array.unshift(bearish_ob_breaker, false)
        while array.size(bearish_ob_top) > showBear
            array.pop(bearish_ob_top)
            array.pop(bearish_ob_btm)
            array.pop(bearish_ob_loc)
            array.pop(bearish_ob_breaker)
        // Box management
        b2 = box.new(time[1], ob_high, time + tf_msec * 2, ob_low, xloc=xloc.bar_time, bgcolor=bearCss, border_color=color.new(color.white, 100))
        array.unshift(boxes_ob_bear, b2)
        if array.size(boxes_ob_bear) > showBear
            box.delete(array.pop(boxes_ob_bear))

// Order Block Break Detection + box color update
if array.size(bullish_ob_top) > 0
    for i = 0 to safe_max_idx(bullish_ob_top, array.size(bullish_ob_top) - 1) by 1
        if not safe_get(bullish_ob_breaker, i, false)
            ob_btm = safe_get(bullish_ob_btm, i, na)
            if not na(ob_btm) and math.min(close, open) < ob_btm
                array.set(bullish_ob_breaker, i, true)
        if i < array.size(boxes_ob_bull)
            bx = safe_get(boxes_ob_bull, i, na)
            if not na(bx)
                box.set_right(bx, time) // extend
                box.set_bgcolor(bx, safe_get(bullish_ob_breaker, i, false) ? bullBrkCss : bullCss)

if array.size(bearish_ob_top) > 0
    for i = 0 to safe_max_idx(bearish_ob_top, array.size(bearish_ob_top) - 1) by 1
        if not safe_get(bearish_ob_breaker, i, false)
            ob_top = safe_get(bearish_ob_top, i, na)
            if not na(ob_top) and math.max(close, open) > ob_top
                array.set(bearish_ob_breaker, i, true)
        if i < array.size(boxes_ob_bear)
            bx2 = safe_get(boxes_ob_bear, i, na)
            if not na(bx2)
                box.set_right(bx2, time)
                box.set_bgcolor(bx2, safe_get(bearish_ob_breaker, i, false) ? bearBrkCss : bearCss)

//=============================================================================
// LIQUIDITY DETECTION (Simplified + idempotent drawing + sweeps)
//=============================================================================

// CHANGE #liq-draw-ids
var boxes_liq_b = array.new_box()
var boxes_liq_s = array.new_box()

if not na(ph) and showLq and per
    // Check for multiple highs around similar levels
    similar_count = 0
    if array.size(pivot_highs) > 0
        for i = 0 to math.min(4, array.size(pivot_highs) - 1)
            ph_val = safe_get(pivot_highs, i, na)
            if not na(ph_val) and math.abs(ph_val - ph) < (atr / liq_margin)
                similar_count += 1

    if similar_count >= 2
        array.unshift(b_liq_B_top, ph + (atr/liq_margin))
        array.unshift(b_liq_B_btm, ph - (atr/liq_margin))
        array.unshift(b_liq_B_left, bar_index - 5)
        array.unshift(b_liq_B_broken, false)

        while array.size(b_liq_B_top) > visLiq
            array.pop(b_liq_B_top)
            array.pop(b_liq_B_btm)
            array.pop(b_liq_B_left)
            array.pop(b_liq_B_broken)


        // === CANONICAL LIQUIDITY BOX MANAGEMENT (BUYSIDE) ===
        liq_price = ph
        liq_time = time
        if similar_count >= 2
            // Build canonical LIQ POI (buyside)
            liq_json = build_liq("BUY", liq_price, liq_time, sweep_against_short)
            // Manage canonical boxes
            b = box.new(bar_index - 5, ph + (atr/liq_margin), bar_index + 10, ph - (atr/liq_margin), xloc=xloc.bar_index, bgcolor=cLIQ_B, border_color=color.new(color.white, 100))
            array.unshift(boxes_liq_b, b)
            if array.size(boxes_liq_b) > visLiq
                box.delete(array.pop(boxes_liq_b))

if not na(pl) and showLq and per
    // Check for multiple lows around similar levels
    similar_count = 0
    if array.size(pivot_lows) > 0
        for i = 0 to math.min(4, array.size(pivot_lows) - 1)
            pl_val = safe_get(pivot_lows, i, na)
            if not na(pl_val) and math.abs(pl_val - pl) < (atr / liq_margin)
                similar_count += 1

    if similar_count >= 2
        array.unshift(b_liq_S_top, pl + (atr/liq_margin))
        array.unshift(b_liq_S_btm, pl - (atr/liq_margin))
        array.unshift(b_liq_S_left, bar_index - 5)
        array.unshift(b_liq_S_broken, false)

        while array.size(b_liq_S_top) > visLiq
            array.pop(b_liq_S_top)
            array.pop(b_liq_S_btm)
            array.pop(b_liq_S_left)
            array.pop(b_liq_S_broken)


        // === CANONICAL LIQUIDITY BOX MANAGEMENT (SELLSIDE) ===
        liq_price_s = pl
        liq_time_s = time
        if similar_count >= 2
            // Build canonical LIQ POI (sellside)
            liq_json_s = build_liq("SELL", liq_price_s, liq_time_s, sweep_against_long)
            // Manage canonical boxes
            b2 = box.new(bar_index - 5, pl + (atr/liq_margin), bar_index + 10, pl - (atr/liq_margin), xloc=xloc.bar_index, bgcolor=cLIQ_S, border_color=color.new(color.white, 100))
            array.unshift(boxes_liq_s, b2)
            if array.size(boxes_liq_s) > visLiq
                box.delete(array.pop(boxes_liq_s))

// Liquidity Break Detection + box color updates
if array.size(b_liq_B_top) > 0
    for i = 0 to safe_max_idx(b_liq_B_top, array.size(b_liq_B_top) - 1) by 1
        if not safe_get(b_liq_B_broken, i, false)
            liq_top = safe_get(b_liq_B_top, i, na)
            if not na(liq_top) and high > liq_top
                array.set(b_liq_B_broken, i, true)
        if i < array.size(boxes_liq_b)
            bx = safe_get(boxes_liq_b, i, na)
            if not na(bx)
                box.set_right(bx, bar_index + 10)
                box.set_bgcolor(bx, safe_get(b_liq_B_broken, i, false) ? color.new(cLIQ_B, 90) : cLIQ_B)

if array.size(b_liq_S_top) > 0
    for i = 0 to safe_max_idx(b_liq_S_top, array.size(b_liq_S_top) - 1) by 1
        if not safe_get(b_liq_S_broken, i, false)
            liq_btm = safe_get(b_liq_S_btm, i, na)
            if not na(liq_btm) and low < liq_btm
                array.set(b_liq_S_broken, i, true)
        if i < array.size(boxes_liq_s)
            bx2 = safe_get(boxes_liq_s, i, na)
            if not na(bx2)
                box.set_right(bx2, bar_index + 10)
                box.set_bgcolor(bx2, safe_get(b_liq_S_broken, i, false) ? color.new(cLIQ_S, 90) : cLIQ_S)

//=============================================================================
// SWEEP DETECTION (explicit, within N candles)  -- SAFE guarded version
//=============================================================================

// Get the most-recent liquidity reference values safely (avoid array.get on empty arrays)
// SAFE: get most-recent liquidity reference values (typed declarations)
float liq_b_top = na
float liq_s_btm = na
if array.size(b_liq_B_top) > 0
    liq_b_top := safe_get(b_liq_B_top, 0, na)
if array.size(b_liq_S_btm) > 0
    liq_s_btm := safe_get(b_liq_S_btm, 0, na)

// Compute sweep NOW / PREV flags using the safe local values
bool bsl_sweep_now  = not na(liq_b_top) and (high  > liq_b_top and close  < liq_b_top)   // buyside sweep (for SHORTs)
bool bsl_sweep_prev = not na(liq_b_top) and (high[1] > liq_b_top and close[1] < liq_b_top)

bool ssl_sweep_now  = not na(liq_s_btm) and (low  < liq_s_btm and close  > liq_s_btm)   // sellside sweep (for LONGs)
bool ssl_sweep_prev = not na(liq_s_btm) and (low[1] < liq_s_btm and close[1] > liq_s_btm)

// Update the global sweep flags (these should be declared once as `var bool` earlier)
sweep_against_short := bsl_sweep_now or (sweep_candles >= 2 and bsl_sweep_prev)
sweep_against_long  := ssl_sweep_now or (sweep_candles >= 2 and ssl_sweep_prev)


//=============================================================================
// PRIOR-DAY PD MID (global for gating & plots)
//=============================================================================

// CHANGE #pd-mid-global
// Use precomputed pd_mid, in_premium, in_discount for global context

//=============================================================================
// RETRACEMENT ENTRY CONDITIONS (FVG mid + OB open close-inside)
//=============================================================================

// Long retrace into active bullish FVG (close inside near/above mid)
var bool long_retrace = false
var bool short_retrace = false


long_retrace := false
if array.size(bFVG_UP_active) > 0 and safe_get(bFVG_UP_active, 0, false)
    fvg_top = safe_get(bFVG_UP_top, 0, na)
    fvg_btm = safe_get(bFVG_UP_btm, 0, na)
    fvg_mid0 = (fvg_top + fvg_btm) / 2.0
    long_retrace := low <= fvg_top and close >= fvg_mid0 and close <= fvg_top

// Short retrace into active bearish FVG (close inside near/below mid)

short_retrace := false
if array.size(bFVG_DN_active) > 0 and safe_get(bFVG_DN_active, 0, false)
    fvg_top2 = safe_get(bFVG_DN_top, 0, na)
    fvg_btm2 = safe_get(bFVG_DN_btm, 0, na)
    fvg_mid1 = (fvg_top2 + fvg_btm2) / 2.0
    short_retrace := high >= fvg_btm2 and close <= fvg_mid1 and close >= fvg_btm2

// OB open approximations (use zone bounds + small buffer)
tick = syminfo.mintick
buff = ob_open_buffer_ticks * tick

// Long: OB is bullish zone [btm..top]; require close inside zone, near lower half as proxy for OB open (refined wick optional by your discretion)

long_ob_tap = false
if array.size(bullish_ob_top) > 0
    ob_t = safe_get(bullish_ob_top, 0, na)
    ob_b = safe_get(bullish_ob_btm, 0, na)
    long_ob_tap := close <= ob_t and close >= ob_b and low <= (ob_b + buff)

// Short: OB is bearish zone [btm..top]; require close inside zone, near upper half

short_ob_tap = false
if array.size(bearish_ob_top) > 0
    ob_t2 = safe_get(bearish_ob_top, 0, na)
    ob_b2 = safe_get(bearish_ob_btm, 0, na)
    short_ob_tap := close <= ob_t2 and close >= ob_b2 and high >= (ob_t2 - buff)

//=============================================================================
// ORDER BLOCKS (Simplified)
//=============================================================================


if not na(ph) and showOB and per
    // Bullish OB on new high
    if array.size(pivot_highs) > 1 and ph > safe_get(pivot_highs, 1, na)
        ob_high = useBody ? math.max(close[1], open[1]) : high[1]
        ob_low = useBody ? math.min(close[1], open[1]) : low[1]
        
        array.unshift(bullish_ob_top, ob_high)
        array.unshift(bullish_ob_btm, ob_low)
        array.unshift(bullish_ob_loc, time[1])
        array.unshift(bullish_ob_breaker, false)
        
        while array.size(bullish_ob_top) > showBull
            array.pop(bullish_ob_top)
            array.pop(bullish_ob_btm)
            array.pop(bullish_ob_loc)
            array.pop(bullish_ob_breaker)

            array.pop(bearish_ob_loc)
            array.pop(bearish_ob_breaker)

if not na(pl) and showOB and per
    // Bearish OB on new low
    if array.size(pivot_lows) > 1 and pl < safe_get(pivot_lows, 1, na)
        ob_high = useBody ? math.max(close[1], open[1]) : high[1]
        ob_low = useBody ? math.min(close[1], open[1]) : low[1]
        
        array.unshift(bearish_ob_top, ob_high)
        array.unshift(bearish_ob_btm, ob_low)
        array.unshift(bearish_ob_loc, time[1])
        array.unshift(bearish_ob_breaker, false)
        
        while array.size(bearish_ob_top) > showBear
            array.pop(bearish_ob_top)
            array.pop(bearish_ob_btm)
            array.pop(bearish_ob_loc)
            array.pop(bearish_ob_breaker)
            array.pop(bearish_ob_loc)
            array.pop(bearish_ob_breaker)

// Order Block Break Detection
if array.size(bullish_ob_top) > 0
    for i = 0 to array.size(bullish_ob_top) - 1 by 1
        if not safe_get(bullish_ob_breaker, i, false)
            ob_btm = safe_get(bullish_ob_btm, i, na)
            if not na(ob_btm) and math.min(close, open) < ob_btm
                array.set(bullish_ob_breaker, i, true)

if array.size(bearish_ob_top) > 0
    for i = 0 to array.size(bearish_ob_top) - 1 by 1
        if not safe_get(bearish_ob_breaker, i, false)
            ob_top = safe_get(bearish_ob_top, i, na)
            if not na(ob_top) and math.max(close, open) > ob_top
                array.set(bearish_ob_breaker, i, true)

//=============================================================================
// LIQUIDITY DETECTION (Simplified)
//=============================================================================

if not na(ph) and showLq and per
    // Check for multiple highs around similar levels
    similar_count = 0
    if array.size(pivot_highs) > 0
        for i = 0 to math.min(4, array.size(pivot_highs) - 1)
            ph_val = safe_get(pivot_highs, i, na)
            if not na(ph_val) and math.abs(ph_val - ph) < (atr / liq_margin)
                similar_count += 1
    
    if similar_count >= 2
        array.unshift(b_liq_B_top, ph + (atr/liq_margin))
        array.unshift(b_liq_B_btm, ph - (atr/liq_margin))
        array.unshift(b_liq_B_left, bar_index - 5)
        array.unshift(b_liq_B_broken, false)
        
        while array.size(b_liq_B_top) > visLiq
            array.pop(b_liq_B_top)
            array.pop(b_liq_B_btm)
            array.pop(b_liq_B_left)
            array.pop(b_liq_B_broken)

if not na(pl) and showLq and per
    // Check for multiple lows around similar levels
    similar_count = 0
    if array.size(pivot_lows) > 0
        for i = 0 to math.min(4, array.size(pivot_lows) - 1)
            pl_val = safe_get(pivot_lows, i, na)
            if not na(pl_val) and math.abs(pl_val - pl) < (atr / liq_margin)
                similar_count += 1
    
    if similar_count >= 2
        array.unshift(b_liq_S_top, pl + (atr/liq_margin))
        array.unshift(b_liq_S_btm, pl - (atr/liq_margin))
        array.unshift(b_liq_S_left, bar_index - 5)
        array.unshift(b_liq_S_broken, false)
        
        while array.size(b_liq_S_top) > visLiq
            array.pop(b_liq_S_top)
            array.pop(b_liq_S_btm)
            array.pop(b_liq_S_left)
            array.pop(b_liq_S_broken)

// Liquidity Break Detection
if array.size(b_liq_B_top) > 0
    for i = 0 to array.size(b_liq_B_top) - 1 by 1
        if not safe_get(b_liq_B_broken, i, false)
            liq_top = safe_get(b_liq_B_top, i, na)
            if not na(liq_top) and high > liq_top
                array.set(b_liq_B_broken, i, true)

if array.size(b_liq_S_top) > 0
    for i = 0 to array.size(b_liq_S_top) - 1 by 1
        if not safe_get(b_liq_S_broken, i, false)
            liq_btm = safe_get(b_liq_S_btm, i, na)
            if not na(liq_btm) and low < liq_btm
                array.set(b_liq_S_broken, i, true)


//=============================================================================
// SIGNAL GENERATION (side-aware confluence + sweep + session + HTF mid)
//=============================================================================

// Daily signal reset
new_day = ta.change(time("D")) != 0
if new_day
    signal_count_today := 0

// Side-aware scores
bullScore = confluence_for_side(true)
bearScore = confluence_for_side(false)

// Legacy aggregate for table compatibility
confluence_score = math.max(bullScore, bearScore)

// Signal validation
can_signal = signal_count_today < max_daily_signals
cooldown_ok = na(last_signal_bar) or (bar_index - last_signal_bar > cooldown_bars)
bull_ok = (regime == 1 or choch_up) and htf_bull and killzone_active and vol_ok and bullScore >= min_confluence
bear_ok = (regime == -1 or choch_down) and htf_bear and killzone_active and vol_ok and bearScore >= min_confluence

// Strict entry gates: require sweep + retrace into zone with close inside
should_alert_buy = bull_ok and (sweep_against_long) and (long_retrace or long_ob_tap) and can_signal and cooldown_ok
should_alert_sell = bear_ok and (sweep_against_short) and (short_retrace or short_ob_tap) and can_signal and cooldown_ok

// TP/SL heuristics
stop_loss_buy = array.size(bullish_ob_btm) > 0 ? safe_get(bullish_ob_btm, 0, low) : low
stop_loss_sell = array.size(bearish_ob_top) > 0 ? safe_get(bearish_ob_top, 0, high) : high
take_profit_buy = close + (close - stop_loss_buy) * 2
take_profit_sell = close - (stop_loss_sell - close) * 2

//=============================================================================
// JSON ALERTS + DEBUG
//=============================================================================


// CHANGE #alertcondition: keep UI-based alert options
alertcondition(true, title="BUY Signal (JSON)", message="JSON in runtime alert")
alertcondition(true, title="SELL Signal (JSON)", message="JSON in runtime alert")

// === PRODUCTION CONTROLS EXTENSION: DETERMINISTIC PAYLOAD FIELDS ===
get_bar_time() =>
    // Use time_close for bar close time in ms (epoch)
    na(time_close) ? na : time_close
get_created_at() =>
    // ISO 8601 UTC string for bar close
    na(time_close) ? "" : str.format_time(time_close, "yyyy-MM-dd'T'HH:mm:ss'Z'")
get_signal_id(side) =>
    // Deterministic ID: symbol|tf|bar_time|side
    t = get_bar_time()
    s = syminfo.ticker + "|" + timeframe.period + "|" + str.tostring(t) + "|" + side
    s


// === PRODUCTION CONTROLS EXTENSION: POI (POINTS OF INTEREST) ===

// === PRODUCTION CONTROLS EXTENSION: STRICT SANITIZE FOR JSON ===
sanitize_string(val) =>
    na(val) ? "null" : '"' + str.tostring(val) + '"'

sanitize_number(val) =>
    na(val) ? "null" : str.tostring(val)

sanitize_bool(val) =>
    na(val) ? "null" : (val ? "true" : "false")

// Helper to format POI object as JSON

// Helper to format POI object as JSON
poi_json(id, type, top, bottom, created_at, confidence, source) =>
    (na(top) or na(bottom)) ? "" :
    '{' +
        '"id":' + sanitize_string(id) + ',' +
        '"type":' + sanitize_string(type) + ',' +
        '"top":' + sanitize_number(format_price(top)) + ',' +
        '"bottom":' + sanitize_number(format_price(bottom)) + ',' +
        '"created_at":' + sanitize_string(created_at) + ',' +
        '"confidence":' + sanitize_number(confidence) + ',' +
        '"source":' + sanitize_string(source) +
    '}'


// Build POI array for current bar

// Build POI array for current bar
build_poi_array(side, bar_time, created_at) =>
    arr = array.new_string()
    seq = 0
    // --- OB (Order Block) used for SL/TP ---
    if side == "BUY" and array.size(bullish_ob_top) > 0 and array.size(bullish_ob_btm) > 0
        ob_top = safe_get(bullish_ob_top, 0, na)
        ob_btm = safe_get(bullish_ob_btm, 0, na)
        ob_id = "POI_" + syminfo.ticker + "_" + timeframe.period + "_" + str.tostring(bar_time) + "_OB_" + str.tostring(seq)
        array.push(arr, poi_json(ob_id, "OB", ob_top, ob_btm, created_at, 1.0, "OB for BUY SL/TP"))
        seq += 1
    if side == "SELL" and array.size(bearish_ob_top) > 0 and array.size(bearish_ob_btm) > 0
        ob_top = safe_get(bearish_ob_top, 0, na)
        ob_btm = safe_get(bearish_ob_btm, 0, na)
        ob_id = "POI_" + syminfo.ticker + "_" + timeframe.period + "_" + str.tostring(bar_time) + "_OB_" + str.tostring(seq)
        array.push(arr, poi_json(ob_id, "OB", ob_top, ob_btm, created_at, 1.0, "OB for SELL SL/TP"))
        seq += 1
    // --- FVGs (Fair Value Gaps) ---
    for i = 0 to safe_max_idx(bFVG_UP_top, 2)
        fvg_top = safe_get(bFVG_UP_top, i, na)
        fvg_btm = safe_get(bFVG_UP_btm, i, na)
        if not na(fvg_top) and not na(fvg_btm)
            fvg_id = "POI_" + syminfo.ticker + "_" + timeframe.period + "_" + str.tostring(bar_time) + "_FVG_UP_" + str.tostring(i)
            array.push(arr, poi_json(fvg_id, "FVG", fvg_top, fvg_btm, created_at, 0.8, "FVG_UP array"))
    for i = 0 to safe_max_idx(bFVG_DN_top, 2)
        fvg_top = safe_get(bFVG_DN_top, i, na)
        fvg_btm = safe_get(bFVG_DN_btm, i, na)
        if not na(fvg_top) and not na(fvg_btm)
            fvg_id = "POI_" + syminfo.ticker + "_" + timeframe.period + "_" + str.tostring(bar_time) + "_FVG_DN_" + str.tostring(i)
            array.push(arr, poi_json(fvg_id, "FVG", fvg_top, fvg_btm, created_at, 0.8, "FVG_DN array"))
    // --- LIQ (Liquidity) ---
    // === CANONICAL LIQUIDITY POI ENTRIES ===
    for i = 0 to safe_max_idx(b_liq_B_top, 2)
        liq_top = safe_get(b_liq_B_top, i, na)
        liq_time = bar_time
        if not na(liq_top)
            sweep_conf = sweep_against_short
            array.push(arr, build_liq("BUY", liq_top, liq_time, sweep_conf))
    for i = 0 to safe_max_idx(b_liq_S_btm, 2)
        liq_btm = safe_get(b_liq_S_btm, i, na)
        liq_time = bar_time
        if not na(liq_btm)
            sweep_conf = sweep_against_long
            array.push(arr, build_liq("SELL", liq_btm, liq_time, sweep_conf))
    arr



// === PRODUCTION CONTROLS EXTENSION: STRUCTURED ENTRY/SL/TP ===
// Helper for entry object
entry_obj(price, type) => '{"price":' + sanitize_number(format_price(price)) + ',"type":' + sanitize_string(type) + '}'
// Helper for SL object
sl_obj(price, type, zone_id) => '{"price":' + sanitize_number(format_price(price)) + ',"type":' + sanitize_string(type) + ',"zone_id":' + sanitize_string(zone_id) + '}'
// Helper for TP object
tp_obj(price, tag, pct) => '{"price":' + sanitize_number(format_price(price)) + ',"tag":' + sanitize_string(tag) + ',"pct":' + sanitize_number(pct) + '}'

// Build TP array (always at least one for backward compatibility)
build_tp_array(tp1, tp2, use_multi) =>
    arr = array.new_string()
    array.push(arr, tp_obj(tp1, "TP1", 50))
    if use_multi and not na(tp2)
        array.push(arr, tp_obj(tp2, "TP2", 30))
    arr


// === PRODUCTION CONTROLS EXTENSION: SCORE BREAKDOWN & CONFIDENCE ===
// Canonical rule logic and score breakdown
rule_scores = array.new_int(array.size(rules_list), 0)
for i = 0 to array.size(rules_list) - 1
    rule = array.get(rules_list, i)
    val = switch rule
        "HTF_ALIGN" => (htf_bull and side == "BUY") or (htf_bear and side == "SELL") ? 1 : 0
        "OB"        => (side == "BUY" and array.size(bullish_ob_top) > 0) or (side == "SELL" and array.size(bearish_ob_top) > 0) ? 1 : 0
        "FVG"       => (side == "BUY" and array.size(bFVG_UP_top) > 0) or (side == "SELL" and array.size(bFVG_DN_top) > 0) ? 1 : 0
        "SWEEP"     => (side == "BUY" and sweep_against_long) or (side == "SELL" and sweep_against_short) ? 1 : 0
        "KILLZONE"  => killzone_active ? 1 : 0
        => 0
    array.set(rule_scores, i, val)

// === CANONICAL SCORE BREAKDOWN (EXPLICIT KEYS) ===
score_htf_align = (htf_bull and side == "BUY") or (htf_bear and side == "SELL") ? 1 : 0
score_ob        = (side == "BUY" and array.size(bullish_ob_top) > 0) or (side == "SELL" and array.size(bearish_ob_top) > 0) ? 1 : 0
score_fvg       = (side == "BUY" and array.size(bFVG_UP_top) > 0) or (side == "SELL" and array.size(bFVG_DN_top) > 0) ? 1 : 0
score_sweep     = (side == "BUY" and sweep_against_long) or (side == "SELL" and sweep_against_short) ? 1 : 0
score_killzone  = killzone_active ? 1 : 0
score_vol       = vol_ok ? 1 : 0
score_breakdown_obj = '{' +
    '"htf_align":' + str.tostring(score_htf_align) + ',' +
    '"ob":' + str.tostring(score_ob) + ',' +
    '"fvg":' + str.tostring(score_fvg) + ',' +
    '"sweep":' + str.tostring(score_sweep) + ',' +
    '"killzone":' + str.tostring(score_killzone) + ',' +
    '"vol":' + str.tostring(score_vol) +
    '}'
// Weighted confidence (all weights = 1 for now)
score_sum = score_htf_align + score_ob + score_fvg + score_sweep + score_killzone + score_vol
total_weight = 6.0
confidence = score_sum / total_weight
confidence_method = "sum_of_keys_v1"

// Extended JSON emitter with deterministic fields, POI array, structured entry/sl/tp, score_breakdown, and confidence
make_json(side, score, entry, sl, tp, sessionName, htf_mid_val) =>
    schema_version = "v2"
    // --- Rule Provenance Array ---
    rule_provenance = array.new_string()
    // Canonical rule_provenance, 1:1 with rules_list
    array.clear(rule_provenance)
    for i = 0 to array.size(rules_list) - 1
        rule = array.get(rules_list, i)
        val = array.get(rule_scores, i)
        meta = switch rule
            "HTF_ALIGN" => '{"htf_mid":' + (not na(htf_mid_val) ? sanitize_number(format_price(htf_mid_val)) : "null") + '}'
            "OB"        => '{"zone_id":' + (side == "BUY" and array.size(bullish_ob_top) > 0 ? sanitize_string("POI_" + syminfo.ticker + "_" + timeframe.period + "_" + str.tostring(bar_time) + "_OB_0") : side == "SELL" and array.size(bearish_ob_top) > 0 ? sanitize_string("POI_" + syminfo.ticker + "_" + timeframe.period + "_" + str.tostring(bar_time) + "_OB_0") : "null") + '}'
            "FVG"       => '{"fvg_count":' + sanitize_number(side == "BUY" ? array.size(bFVG_UP_top) : array.size(bFVG_DN_top)) + '}'
            "SWEEP"     => '{"sweep_flag":' + sanitize_bool((side == "BUY" and sweep_against_long) or (side == "SELL" and sweep_against_short)) + '}'
            "KILLZONE"  => '{"session":' + sanitize_string(sessionName) + '}'
            "VOL"       => '{"vol_ok":' + sanitize_bool(vol_ok) + '}'
            => '{}'
        array.push(rule_provenance, '{' +
            '"rule":' + sanitize_string(rule) + ',' +
            '"value":' + sanitize_bool(val == 1) + ',' +
            '"score":' + sanitize_number(val) + ',' +
            '"metadata":' + meta +
        '}')
    bar_time = get_bar_time()
    created_at = get_created_at()
    signal_id = get_signal_id(side)
    idx = bar_index
    poi_arr = build_poi_array(side, bar_time, created_at)
    poi_json_str = "[" + array.join(poi_arr, ",") + "]"
    // --- Structured entry ---
    entry_type = "close"  // can be extended to "limit"/"midpoint" as needed
    entry_json = entry_obj(entry, entry_type)
    // --- Structured SL ---
    sl_type = "zone_bottom"
    sl_zone_id = ""
    if side == "BUY" and array.size(bullish_ob_top) > 0 and array.size(bullish_ob_btm) > 0
        sl_zone_id := "POI_" + syminfo.ticker + "_" + timeframe.period + "_" + str.tostring(bar_time) + "_OB_0"
    if side == "SELL" and array.size(bearish_ob_top) > 0 and array.size(bearish_ob_btm) > 0
        sl_zone_id := "POI_" + syminfo.ticker + "_" + timeframe.period + "_" + str.tostring(bar_time) + "_OB_0"
    sl_json = sl_obj(sl, sl_type, sl_zone_id)
    // --- Structured TP array ---
    use_multi_tp = true  // can be toggled/configured
    tp1 = tp
    tp2 = na  // extend with more TPs as needed
    tp_arr = build_tp_array(tp1, tp2, use_multi_tp)
    tp_json_str = "[" + array.join(tp_arr, ",") + "]"
    idempotency_key = signal_id + "|" + detector_version
    // --- Defensive fields_present and notes ---
    fields_present = array.new_string()
    notes = ""
    // List all fields and check for na
    // Minimal mode fields
    if not na(signal_id)
        array.push(fields_present, "signal_id")
    if not na(created_at)
        array.push(fields_present, "created_at")
    if not na(syminfo.ticker)
        array.push(fields_present, "symbol")
    if not na(timeframe.period)
        array.push(fields_present, "tf")
    if not na(side)
        array.push(fields_present, "side")
    if not na(entry)
        array.push(fields_present, "entry")
    if not na(sl)
        array.push(fields_present, "sl")
    if not na(tp)
        array.push(fields_present, "tp")
    if not na(detector_version)
        array.push(fields_present, "detector_version")
    if not na(idempotency_key)
        array.push(fields_present, "idempotency_key")
    // Full mode extra fields
    if not minimal_mode
        if not na(pine_version)
            array.push(fields_present, "pine_version")
        if not na(bar_time)
            array.push(fields_present, "bar_time")
        if not na(idx)
            array.push(fields_present, "bar_index")
        if not na(score)
            array.push(fields_present, "score")
        if not na(score_breakdown_obj)
            array.push(fields_present, "score_breakdown")
        if not na(confidence)
            array.push(fields_present, "confidence")
        if not na(confidence_method)
            array.push(fields_present, "confidence_method")
        if not na(sessionName)
            array.push(fields_present, "session")
        if not na(htf_mid_val)
            array.push(fields_present, "htf_mid")
        else
            notes := notes + "htf_mid unavailable: insufficient history; "
        if not na(regime)
            array.push(fields_present, "regime")
        if not na(choch_up)
            array.push(fields_present, "choch_up")
        if not na(choch_down)
            array.push(fields_present, "choch_down")
        if not na(bos_up)
            array.push(fields_present, "bos_up")
        if not na(bos_down)
            array.push(fields_present, "bos_down")
        if not na(poi_json_str)
            array.push(fields_present, "poi")

    // --- Emit fields_present as valid JSON array of quoted strings ---
    fields_present_json = array.size(fields_present) == 0 ? "[]" : '["' + array.join(fields_present, '","') + '"]'
    // --- Minimal Payload Mode ---
    // SECURITY: No secrets, tokens, or credentials are ever included in the JSON payload.
    if minimal_mode
        '{' +
            '"schema_version":"' + schema_version + '",' +
            '"signal_id":' + safe_get(signal_id, "signal_id") + ',' +
            '"created_at":' + safe_get(created_at, "created_at") + ',' +
            '"symbol":' + safe_get(syminfo.ticker, "symbol") + ',' +
            '"tf":' + safe_get(timeframe.period, "tf") + ',' +
            '"side":' + safe_get(side, "side") + ',' +
            '"entry":' + safe_get(entry, "entry") + ',' +
            '"sl":' + safe_get(sl, "sl") + ',' +
            '"tp":' + safe_get(tp, "tp") + ',' +
            '"detector_version":' + safe_get(detector_version, "detector_version") + ',' +
            '"idempotency_key":' + safe_get(idempotency_key, "idempotency_key") + ',' +
            '"fields_present":' + fields_present_json +
            (notes != "" ? ',"notes":"' + notes + '"' : "") +
            ',"rule_provenance":[' + array.join(rule_provenance, ",") + ']'
            + (legacy_mode ? ',"entry_price":' + (not na(entry) ? format_price(entry) : "null") + ',"sl_price":' + (not na(sl) ? format_price(sl) : "null") + ',"tp_price":' + (not na(tp) ? format_price(tp) : "null") : "")
        '}'
    else
        '{' +
            '"schema_version":"' + schema_version + '",' +
            '"signal_id":' + safe_get(signal_id, "signal_id") + ',' +
            '"idempotency_key":' + safe_get(idempotency_key, "idempotency_key") + ',' +
            '"detector_version":' + safe_get(detector_version, "detector_version") + ',' +
            '"pine_version":' + safe_get(pine_version, "pine_version") + ',' +
            '"created_at":' + safe_get(created_at, "created_at") + ',' +
            '"bar_time":' + safe_get(bar_time, "bar_time") + ',' +
            '"bar_index":' + safe_get(idx, "bar_index") + ',' +
            '"symbol":' + safe_get(syminfo.ticker, "symbol") + ',' +
            '"tf":' + safe_get(timeframe.period, "tf") + ',' +
            '"side":' + safe_get(side, "side") + ',' +
            '"score":' + safe_get(score, "score") + ',' +
            '"score_breakdown":' + (not na(score_breakdown_obj) ? score_breakdown_obj : 'null') + ',' +
            '"confidence":' + safe_get(confidence, "confidence") + ',' +
            '"confidence_method":' + safe_get(confidence_method, "confidence_method") + ',' +
            '"entry":' + safe_get(entry, "entry") + ',' +
            '"sl":' + safe_get(sl, "sl") + ',' +
            '"tp":' + safe_get(tp, "tp") + ',' +
            '"session":' + safe_get(sessionName, "session") + ',' +
            '"htf_mid":' + (not na(htf_mid_val) ? safe_get(format_price(htf_mid_val), "htf_mid") : "null") + ',' +
            '"regime":' + safe_get(regime, "regime") + ',' +
            '"choch_up":' + safe_get(choch_up, "choch_up") + ',' +
            '"choch_down":' + safe_get(choch_down, "choch_down") + ',' +
            '"bos_up":' + safe_get(bos_up, "bos_up") + ',' +
            '"bos_down":' + safe_get(bos_down, "bos_down") + ',' +
            '"poi":' + safe_get(poi_json_str, "poi") + ',' +
            '"fields_present":' + fields_present_json +
            (notes != "" ? ',"notes":"' + notes + '"' : "") +
            ',"rule_provenance":[' + array.join(rule_provenance, ",") + ']'
            + (legacy_mode ? ',"entry_price":' + (not na(entry) ? format_price(entry) : "null") + ',"sl_price":' + (not na(sl) ? format_price(sl) : "null") + ',"tp_price":' + (not na(tp) ? format_price(tp) : "null") : "")
        '}'
// --- Log warning if legacy_mode is enabled ---
if legacy_mode and barstate.islast
    label.new(bar_index, high, "[LEGACY MODE ENABLED] Flat fields are present for migration. This mode will be removed in the next major version.", style=label.style_label_down, color=color.yellow, textcolor=color.black, size=size.small)


session_text = is_london_session ? "LONDON" : is_ny_session ? "NEW_YORK" : "OTHER"


//==============================
// PRODUCTION ALERT GATING LAYER
//==============================


// === PRODUCTION CONTROLS: ALERT FIRING SEMANTICS ===
// Alerts fire exactly once per bar close when trigger=true.
// In dev mode, alerts are replaced with debug labels (no alerts sent).


// BUY SIGNAL
// emit_allowed respects the new `use_emit_guard` toggle:
// - if use_emit_guard is true, require barstate.isconfirmed
// - if false, allow original gating to proceed (no extra confirmation required)
emit_allowed = use_emit_guard ? (should_alert_buy and barstate.isconfirmed) : should_alert_buy
if emit_allowed
    entry_candidate = get_entry_candidate()
    if is_valid_signal(signal_id, entry_candidate, stop_loss_buy, take_profit_buy)
        signal_count_today += 1
        last_signal_bar := bar_index
        json_alert = make_json("BUY", bullScore, entry_candidate, stop_loss_buy, take_profit_buy, session_text, htf_mid)
        // --- PAYLOAD SIZE SAFEGUARD ---
        payload_to_send = json_alert
        if str.length(payload_to_send) > 2000
            payload_to_send := make_json("BUY", bullScore, entry_candidate, stop_loss_buy, take_profit_buy, session_text, htf_mid)
            log_error("[WARN] Payload exceeded 2000 chars. Fallback to minimal mode.")
        // --- Observability: check for invalid fields (nulls in required fields) ---
        invalid = not is_valid_payload(payload_to_send)
        if _debug_mode or not can_fire_alerts
            alerts_skipped_due_debug += 1
            // Dev mode: show debug label with signal_id and confidence
            label.new(bar_index, low, "🟢 BUY\nID: " + get_signal_id("BUY") + "\nConfidence: " + str.tostring(bullScore) + "\n" + payload_to_send, style=label.style_label_up, color=color.lime, textcolor=color.white, size=size.normal)
            log_error("[DEBUG] BUY signal label only (env=" + env_mode + ", alerts=" + str.tostring(enableProdAlerts) + ")")
            if invalid
                alerts_invalid_fields += 1
            push_test_payload(payload_to_send)
        else if should_emit_alert()
            // Production: fire alert exactly once per bar close
            alert(payload_to_send, alert.freq_once_per_bar_close)
            alerts_emitted += 1
            if invalid
                alerts_invalid_fields += 1
        else
            log_error("[SKIP] BUY alert gated by production controls (max/day or env)")
    else
        log_error("[SKIP] BUY signal skipped: entry/sl/tp invalid (na)")

// SELL SIGNAL
// SELL SIGNAL
// emit_allowed respects the new `use_emit_guard` toggle
emit_allowed_sell = use_emit_guard ? (should_alert_sell and barstate.isconfirmed) : should_alert_sell
if emit_allowed_sell
    entry_candidate = get_entry_candidate()
    if is_valid_signal(signal_id, entry_candidate, stop_loss_sell, take_profit_sell)
        signal_count_today += 1
        last_signal_bar := bar_index
        json_alert = make_json("SELL", bearScore, entry_candidate, stop_loss_sell, take_profit_sell, session_text, htf_mid)
        // --- PAYLOAD SIZE SAFEGUARD ---
        payload_to_send = json_alert
        if str.length(payload_to_send) > 2000
            payload_to_send := make_json("SELL", bearScore, entry_candidate, stop_loss_sell, take_profit_sell, session_text, htf_mid)
            log_error("[WARN] Payload exceeded 2000 chars. Fallback to minimal mode.")
        invalid = not is_valid_payload(payload_to_send)
        if _debug_mode or not can_fire_alerts
            alerts_skipped_due_debug += 1
            label.new(bar_index, high, "🔴 SELL\nID: " + get_signal_id("SELL") + "\nConfidence: " + str.tostring(bearScore) + "\n" + payload_to_send, style=label.style_label_down, color=color.red, textcolor=color.white, size=size.normal)
            log_error("[DEBUG] SELL signal label only (env=" + env_mode + ", alerts=" + str.tostring(enableProdAlerts) + ")")
            if invalid
                alerts_invalid_fields += 1
            push_test_payload(payload_to_send)
        else if should_emit_alert()
            alert(payload_to_send, alert.freq_once_per_bar_close)
            alerts_emitted += 1
            if invalid
                alerts_invalid_fields += 1
        else
            log_error("[SKIP] SELL alert gated by production controls (max/day or env)")
    else
        log_error("[SKIP] SELL signal skipped: entry/sl/tp invalid (na)")

// --- Dev mode: show counters and latest signal info every N bars ---
if env_mode == "dev" and _debug_mode and bar_index % debug_label_interval == 0 and barstate.islast
    label.new(bar_index, high + 5 * syminfo.mintick, "[DEBUG] alerts_emitted: " + str.tostring(alerts_emitted) + "\nalerts_skipped_due_debug: " + str.tostring(alerts_skipped_due_debug) + "\nalerts_invalid_fields: " + str.tostring(alerts_invalid_fields), style=label.style_label_down, color=color.new(color.purple, 0), textcolor=color.white, size=size.normal)
    // Object leak checker (diagnostic only)
    if debugMode
        // Show counts of debug-created objects and sizes of some key arrays
        obj_info = "DBG_LABELS:" + str.tostring(__debug_created_labels) + " | DBG_BOXES:" + str.tostring(__debug_created_boxes)
        // try to show POI/OB/FVG counts if arrays exist (safe_get returns na if undefined)
        poi_cnt = na
        ob_cnt = na
        fvg_cnt = na
        // Use safe wrappers to avoid runtime error if arrays are not present
        poi_cnt := (typeof(bullish_ob_top) != na) ? str.tostring(array.size(bullish_ob_top)) : "?"
        ob_cnt := (typeof(bullish_ob_top) != na) ? "B:" + str.tostring(array.size(bullish_ob_top)) + "/S:" + str.tostring(array.size(bearish_ob_top)) : "?"
        fvg_cnt := (typeof(bFVG_UP_top) != na) ? str.tostring(array.size(bFVG_UP_top) + array.size(bFVG_DN_top)) : "?"
        label.new(bar_index, high + 10 * syminfo.mintick, "[LEAK CHECK] " + obj_info + " | OB:" + ob_cnt + " | FVG:" + fvg_cnt, style=label.style_label_down, color=color.new(color.fuchsia, 0), textcolor=color.white, size=size.small)

// --- Optional: plotchar for counters (dev only) ---
plotchar(env_mode == "dev" and _debug_mode ? alerts_emitted : na, title="Alerts Emitted (dev)", color=color.green, location=location.top, offset=-1)
plotchar(env_mode == "dev" and _debug_mode ? alerts_skipped_due_debug : na, title="Alerts Skipped (dev)", color=color.orange, location=location.top, offset=-2)
plotchar(env_mode == "dev" and _debug_mode ? alerts_invalid_fields : na, title="Alerts Invalid Fields (dev)", color=color.red, location=location.top, offset=-3)


// Toggle to use legacy redraws (default OFF)
use_legacy_redraw = input.bool(false, "Use Legacy Redraw (barstate.islast)", group="Sessions & Killzones")

// DIAGNOSTIC VISUALS — remove after confirming
if barstate.islast
    label.new(bar_index, high, "VIS OK", style=label.style_label_down, color=color.new(color.blue, 0), textcolor=color.white, size=size.tiny)
    box.new(bar_index - 20, high, bar_index - 10, high - (atr * 0.2), xloc=xloc.bar_index, bgcolor=color.new(color.blue, 80), border_color=color.new(color.blue, 0))

if barstate.islast and use_legacy_redraw
    // Legacy redraws for OB/FVG/LIQ are disabled by default. Enable use_legacy_redraw to use them.
    // ...existing code for info table and backgrounds remains...

//=============================================================================
// SESSION BACKGROUNDS
//=============================================================================

ny_session = is_ny_session and showNy
london_open = is_london_session and showLdno

bgcolor(per ? ny_session ? nyCss : na : na, editable=false)
bgcolor(per ? london_open ? ldnoCss : na : na, editable=false)

//=============================================================================
// INFORMATION PANEL
//=============================================================================

if barstate.islast
    var table info_table = table.new(position.top_right, 2, 8, bgcolor=color.new(color.black, 80), border_width=1)
    
    table.cell(info_table, 0, 0, "Market Structure", text_color=color.white, text_size=size.small)
    table.cell(info_table, 1, 0, MSS_dir == 1 ? "BULLISH" : MSS_dir == -1 ? "BEARISH" : "NEUTRAL", 
              text_color=MSS_dir == 1 ? color.lime : MSS_dir == -1 ? color.red : color.gray, text_size=size.small)
    
    table.cell(info_table, 0, 1, "Confluence Score", text_color=color.white, text_size=size.small)
    table.cell(info_table, 1, 1, str.tostring(confluence_score) + "/8", 
              text_color=confluence_score >= min_confluence ? color.lime : color.orange, text_size=size.small)
    
    table.cell(info_table, 0, 2, "Active FVGs", text_color=color.white, text_size=size.small)
    active_fvg_count = 0
    if array.size(bFVG_UP_active) > 0
        for i = 0 to safe_max_idx(bFVG_UP_active, 2)
            if safe_get(bFVG_UP_active, i, false)
                active_fvg_count += 1
    if array.size(bFVG_DN_active) > 0
        for i = 0 to safe_max_idx(bFVG_DN_active, 2)
            if safe_get(bFVG_DN_active, i, false)
                active_fvg_count += 1
    table.cell(info_table, 1, 2, str.tostring(active_fvg_count), text_color=color.yellow, text_size=size.small)
    
    table.cell(info_table, 0, 3, "Order Blocks", text_color=color.white, text_size=size.small)
    table.cell(info_table, 1, 3, "B:" + str.tostring(array.size(bullish_ob_top)) + " | S:" + str.tostring(array.size(bearish_ob_top)), 
              text_color=color.aqua, text_size=size.small)
    
    table.cell(info_table, 0, 4, "Liquidity Zones", text_color=color.white, text_size=size.small)
    table.cell(info_table, 1, 4, "BSL:" + str.tostring(array.size(b_liq_B_top)) + " | SSL:" + str.tostring(array.size(b_liq_S_top)), 
              text_color=color.orange, text_size=size.small)
    
    table.cell(info_table, 0, 5, "Session", text_color=color.white, text_size=size.small)
    session_text := is_london_session ? "LONDON" : is_ny_session ? "NEW YORK" : "OTHER"
    table.cell(info_table, 1, 5, session_text, text_color=killzone_active ? color.lime : color.gray, text_size=size.small)
    
    table.cell(info_table, 0, 6, "Signals Today", text_color=color.white, text_size=size.small)
    table.cell(info_table, 1, 6, str.tostring(signal_count_today) + "/" + str.tostring(max_daily_signals), 
              text_color=signal_count_today < max_daily_signals ? color.lime : color.red, text_size=size.small)
    
    table.cell(info_table, 0, 7, "Last Signal", text_color=color.white, text_size=size.small)
    bars_since_signal = na(last_signal_bar) ? na : bar_index - last_signal_bar
    signal_status = na(bars_since_signal) ? "NONE" : bars_since_signal < cooldown_bars ? "COOLDOWN(" + str.tostring(cooldown_bars - bars_since_signal) + ")" : "READY"
    table.cell(info_table, 1, 7, signal_status, 
              text_color=signal_status == "READY" ? color.lime : signal_status == "NONE" ? color.gray : color.orange, text_size=size.small)

//=============================================================================
// PLOTS & VISUAL INDICATORS
//=============================================================================

// Confluence strength indicator
plotchar(confluence_score >= min_confluence and killzone_active, char="★", location=location.top, 
         color=color.yellow, size=size.small, title="High Confluence Zone")

// Market structure trend indicator
mss_dir_change = ta.change(MSS_dir)
plotshape(MSS_dir == 1 and mss_dir_change != 0, style=shape.triangleup, location=location.belowbar, 
         color=color.lime, size=size.small, title="Bullish Structure")
plotshape(MSS_dir == -1 and mss_dir_change != 0, style=shape.triangledown, location=location.abovebar, 
         color=color.red, size=size.small, title="Bearish Structure")

// Premium/Discount zone lines (optional)
plot(premium_zone, title="Premium Zone", color=color.new(color.red, 80), linewidth=1, display=display.none)
plot(discount_zone, title="Discount Zone", color=color.new(color.green, 80), linewidth=1, display=display.none)

//=============================================================================
// END OF HYBRID ICT TRADING SYSTEM
//=============================================================================